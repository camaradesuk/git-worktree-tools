---
phase: 05-in-process-delegation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/wt/clean.ts
  - src/cli/wt/config.ts
  - src/cli/wt/config.test.ts
autonomous: true

must_haves:
  truths:
    - 'Running `wt clean` enters interactive cleanup mode without spawning a child process'
    - 'Running `wt clean --all --json` outputs valid JSON without spawning a child process'
    - 'Running `wt clean 42` cleans a specific PR worktree without spawning a child process'
    - 'Running `wt config show` displays config without spawning a child process'
    - 'Running `wt config set baseBranch develop` sets config without spawning a child process'
    - 'Running `wt --verbose clean` produces debug output from the shared logger singleton'
  artifacts:
    - path: 'src/cli/wt/clean.ts'
      provides: 'Direct library call handler for wt clean'
      contains: 'gatherPrWorktreeInfo'
    - path: 'src/cli/wt/config.ts'
      provides: 'Direct library call handler for all wt config subcommands'
      contains: 'no runSubcommand import'
  key_links:
    - from: 'src/cli/wt/clean.ts'
      to: 'src/lib/cleanpr/index.js'
      via: 'direct import of gatherPrWorktreeInfo, cleanWorktree, getCleanableWorktrees, etc.'
      pattern: 'import.*from.*lib/cleanpr'
    - from: 'src/cli/wt/config.ts'
      to: 'src/cli/wtconfig.js'
      via: 'direct import of library functions instead of runSubcommand'
      pattern: 'no.*runSubcommand'
---

<objective>
Replace `runSubcommand('cleanpr', args)` in `wt/clean.ts` and the remaining `runSubcommand('wtconfig', ...)` calls in `wt/config.ts` with direct library function calls. The cleanpr migration requires lifting the orchestration logic from `src/cli/cleanpr.ts` into the handler. The config migration replaces the subprocess delegation for show/get/set/edit/init/migrate subcommands.

Purpose: Eliminate subprocess spawning for the medium-complexity wt subcommands, completing the wt handler migration alongside plan 05-01.
Output: `wt clean` and `wt config` call library functions directly in-process.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-in-process-delegation/05-RESEARCH.md

@src/cli/wt/clean.ts
@src/cli/wt/config.ts
@src/cli/cleanpr.ts
@src/cli/wtconfig.ts
@src/lib/cleanpr/index.ts
@src/cli/wt/prs.ts (reference pattern: direct library call in wt handler)
@src/cli/wt/config.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate wt/clean.ts from subprocess to direct library calls</name>
  <files>
    src/cli/wt/clean.ts
  </files>
  <action>
Replace the entire handler in `wt/clean.ts` that builds args and calls `runSubcommand('cleanpr', args, envOverrides)` with direct library calls, porting the orchestration from `src/cli/cleanpr.ts`.

**New imports** (replace `runSubcommand` import):

```typescript
import { execSync } from 'child_process';
import * as path from 'path';
import * as git from '../../lib/git.js';
import * as github from '../../lib/github.js';
import * as prompts from '../../lib/prompts.js';
import { withSpinner } from '../../lib/prompts.js';
import * as colors from '../../lib/colors.js';
import { logger } from '../../lib/logger.js';
import { loadConfig } from '../../lib/config.js';
import {
  gatherPrWorktreeInfo,
  createDefaultDeps,
  groupWorktreesByState,
  getCleanableWorktrees,
  findWorktreeByPrNumber,
  cleanWorktree,
  summarizeResults,
} from '../../lib/cleanpr/index.js';
import type {
  CleanOptions,
  WorktreeInfo,
  CleanupDeps,
  CleanupResult,
} from '../../lib/cleanpr/index.js';
import {
  createSuccessResult,
  createErrorResult,
  formatJsonResult,
  ErrorCode,
  getErrorCodeFromError,
  type CleanprResultData,
  type CleanprDryRunData,
  type CleanedWorktreeInfo,
} from '../../lib/json-output.js';
import {
  printStatus,
  printHeader,
  printDim,
  printNextSteps,
  printError,
  errorToDisplay,
  setJsonMode,
  changeIndicator,
} from '../../lib/ui/index.js';
```

**Port helper functions from cleanpr.ts into the file** (before the command export):

- `createCleanupDeps(repoRoot: string): CleanupDeps` (lines 60-96 of cleanpr.ts)
- `printWorktree(w: WorktreeInfo): void` (lines 101-104)
- `resultToCleanedInfo(result: CleanupResult, worktree: WorktreeInfo): CleanedWorktreeInfo` (lines 109-118)
- `outputJsonResult(results: CleanupResult[], worktrees: WorktreeInfo[], dryRun: boolean): void` (lines 123-179)
- `outputJsonError(code: ErrorCode, message: string): void` (lines 184-186)
- `interactiveClean(worktrees, repoRoot, options)` (lines 191-302)
- `cleanAll(worktrees, repoRoot, options)` (lines 307-365)
- `cleanSpecific(prNumber, worktrees, repoRoot, config, options)` (lines 370-426)

**Rewrite the handler** as `async (argv) => { ... }`:

1. Build `CleanOptions` from argv: `{ all: !!argv.all, dryRun: !!argv['dry-run'], force: !!argv.force, deleteRemote: !!argv['delete-remote'], json: !!argv.json, verbose: !!argv.verbose, quiet: !!argv.quiet, noColor: !!argv.noColor }`
2. `setJsonMode(options.json)`
3. Check prerequisites: `github.isGhInstalled()` with error handling
4. Get repo root: `git.getRepoRoot()` with error handling
5. Load config: `loadConfig(repoRoot)`
6. Gather worktree info (with spinner for non-JSON)
7. Route to cleanSpecific / cleanAll / interactiveClean based on argv.prNumber / options.all
8. Wrap in try/catch with JSON-aware error output

Important: Do NOT call `initializeLogger()` -- already done by wt.ts.
Important: Use `logger.debug()` for debug logging (logger singleton already configured).

Note about `printNextSteps`: The legacy cleanpr.ts references `lswt` and `newpr` commands. Update these to reference `wt list` and `wt new` instead:

- `{ command: 'wt list', description: 'List remaining worktrees' }`
- `{ command: 'wt new "feature description"', description: 'Create a new PR' }`
- `{ command: 'wt clean --all', description: 'Clean all merged/closed PRs' }`
  </action>
  <verify>

1. `npm run build` succeeds
2. `npm test` passes
3. Grep for `runSubcommand` in `src/cli/wt/clean.ts` returns no results
4. Grep for `gatherPrWorktreeInfo` in `src/cli/wt/clean.ts` returns a match
   </verify>
   <done>
   wt/clean.ts calls cleanpr library functions directly; no subprocess spawning; all tests pass.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Migrate wt/config.ts remaining subprocess calls and update tests</name>
  <files>
    src/cli/wt/config.ts
    src/cli/wt/config.test.ts
  </files>
  <action>
The current `wt/config.ts` already handles `interactive`, `validate`, `schema`, and single-key `set` directly. It delegates `show`, `get`, `set` (with key+value), `edit`, `init`, and `migrate` to `runSubcommand('wtconfig', ...)`.

Replace each remaining subprocess delegation with direct library calls by importing from the wtconfig modules.

**For `show` subcommand:**
Import and call `formatConfigDisplay()` + `loadMergedConfig()` from `../../lib/wtconfig/index.js` (these are already imported in wtconfig.ts). If `--json` passed, wrap in `createSuccessResult`.

```typescript
case 'show': {
  const repoRoot = getRepoRoot();
  const config = loadMergedConfig(repoRoot ?? undefined);
  if (argv.json) {
    console.log(formatJsonResult(createSuccessResult('wtconfig', { config: config.config, source: config.source })));
  } else {
    console.log(formatConfigDisplay(repoRoot ?? undefined));
  }
  return;
}
```

Import `loadMergedConfig`, `formatConfigDisplay` from `../../lib/wtconfig/index.js`.
Import `createSuccessResult`, `formatJsonResult` from `../../lib/json-output.js`.

**For `get` subcommand:**

```typescript
case 'get': {
  if (args.length === 0) { printError({ title: 'Missing key argument' }); process.exit(1); }
  const repoRoot = getRepoRoot();
  const value = getConfigValue(repoRoot ?? undefined, args[0]);
  if (argv.json) {
    console.log(formatJsonResult(createSuccessResult('wtconfig', { key: args[0], value })));
  } else if (value !== undefined) {
    console.log(value);
  } else {
    printError({ title: `Key "${args[0]}" not found in configuration` });
    process.exit(1);
  }
  return;
}
```

Import `getConfigValue` from `../../lib/wtconfig/index.js`.

**For `set` (with key+value) subcommand:**
Currently, `set` with 2 args delegates to wtconfig. Handle it directly:

```typescript
case 'set': {
  if (args.length === 1) { await handleQuickEdit(args[0]); return; }
  if (args.length < 2) { printError({ title: 'Usage: wt config set <key> <value>' }); process.exit(1); }
  const repoRoot = getRepoRoot();
  if (!repoRoot) { console.error(colors.error('Not in a git repository.')); process.exit(1); }
  setConfigValue(repoRoot, args[0], args[1]);
  console.log(colors.success(`Set ${args[0]} = ${args[1]}`));
  return;
}
```

Import `setConfigValue` from `../../lib/wtconfig/index.js`.

**For `edit` subcommand:**
The wtconfig `edit` command opens the config file in the system editor. Replicate this:

```typescript
case 'edit': {
  const repoRoot = getRepoRoot();
  const configPath = getConfigPath(repoRoot ?? undefined);
  if (!configPath) {
    printError({ title: 'No configuration file found.', hint: 'Run "wt init" to create one.' });
    process.exit(1);
  }
  const editor = process.env.EDITOR || process.env.VISUAL || 'vi';
  const { spawnSync } = await import('child_process');
  spawnSync(editor, [configPath], { stdio: 'inherit' });
  return;
}
```

Note: `getConfigPath` is already imported in the file. For the editor, use `getEditorCommand` from `../../lib/wtconfig/index.js` if available, or fall back to `EDITOR` env var.

Actually, check what `wtconfig edit` does -- it may use `getEditorCommand()`. Import that function and use it.

**For `init` subcommand:**
The wtconfig `init` runs the interactive setup wizard. This is already handled by `wt init` command. The `wt config init` path should just call the same logic. The simplest approach: redirect to the init handler or call the wtconfig init function directly.

Check `wtconfig.ts` to see what `init` does -- it likely calls an `initWizard()` function. Import and call that.

Actually, the simplest and cleanest approach: since `wt init` already exists as a dedicated command, have `wt config init` delegate to the same functions. The wtconfig init is the old "setup wizard" which is interactive. Import the relevant setup functions.

If this gets complex, a pragmatic approach: use `spawnSync` to call the wtconfig init as a fallback ONLY for init and edit, since these are inherently interactive and rarely used programmatically. But the goal is to eliminate ALL subprocess calls, so try direct calls first.

**For `migrate` subcommand:**

```typescript
case 'migrate': {
  const repoRoot = getRepoRoot();
  if (!repoRoot) { console.error(colors.error('Not in a git repository.')); process.exit(1); }
  const issues = detectMigrationIssues(repoRoot);
  if (issues.length === 0) {
    if (argv.json) {
      console.log(formatJsonResult(createSuccessResult('wtconfig', { migrated: false, message: 'No migration needed' })));
    } else {
      printStatus('success', 'No migration needed.');
    }
    return;
  }
  const report = runMigration(repoRoot);
  if (argv.json) {
    console.log(formatJsonResult(createSuccessResult('wtconfig', formatMigrationReportJSON(report))));
  } else {
    console.log(formatMigrationReport(report));
  }
  return;
}
```

Import `detectMigrationIssues`, `runMigration`, `formatMigrationReport` from `../../lib/config-migration/index.js` (already imported in config.ts).
Import `formatMigrationReportJSON` from `../../lib/config-migration/index.js` if it exists (check wtconfig.ts for the JSON output pattern).

**Remove the `runSubcommand` import** and the fallthrough delegation at the bottom of the handler.

**Update the handler structure**: Instead of the current if/else chain with a fallthrough to `runSubcommand`, use a switch/case on `subcommand` that handles all cases. Keep the existing direct handlers for `interactive`, `validate`, `schema`.

**Update `src/cli/wt/config.test.ts`**:

- Remove the mock for `runSubcommand`
- Update test expectations: instead of asserting `runSubcommand` was called with specific args, assert the actual output (mock the library functions)
- Mock `../../lib/wtconfig/index.js` for the new direct calls
- Tests for show, get, set, edit, init, migrate subcommands should verify the library functions are called correctly
  </action>
  <verify>

1. `npm run build` succeeds
2. `npm test` passes
3. Grep for `runSubcommand` in `src/cli/wt/config.ts` returns no results
4. `src/cli/wt/config.test.ts` tests pass without mocking runSubcommand
   </verify>
   <done>
   wt/config.ts handles all subcommands via direct library calls; no subprocess spawning; tests updated to verify direct calls.
   </done>
   </task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. `npm test` passes (full suite)
3. No `runSubcommand` import or call remains in `src/cli/wt/clean.ts` or `src/cli/wt/config.ts`
4. `src/cli/wt/clean.ts` imports from `../../lib/cleanpr/`
5. `src/cli/wt/config.ts` has no `run-command.js` import
</verification>

<success_criteria>

- wt clean calls cleanpr library functions directly without subprocess spawning
- wt config handles all subcommands (show, get, set, edit, init, migrate) without subprocess spawning
- All existing tests pass; config tests updated for direct call pattern
- Build succeeds on all platforms
  </success_criteria>

<output>
After completion, create `.planning/phases/05-in-process-delegation/05-02-SUMMARY.md`
</output>
