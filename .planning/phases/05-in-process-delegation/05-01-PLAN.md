---
phase: 05-in-process-delegation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/wt/list.ts
  - src/cli/wt/state.ts
  - src/lib/lswt/table.ts
  - src/lib/lswt/index.ts
  - src/cli/lswt.ts
  - src/lib/lswt/table.test.ts
autonomous: true

must_haves:
  truths:
    - 'Running `wt list` displays worktree table without spawning a child process'
    - 'Running `wt list --json` outputs valid JSON without spawning a child process'
    - 'Running `wt list --interactive` enters interactive mode in-process'
    - 'Running `wt state` displays state analysis without spawning a child process'
    - 'Running `wt state --json` outputs valid JSON without spawning a child process'
    - 'Running `wt --verbose list` produces debug output from the shared logger singleton (not a child process logger)'
  artifacts:
    - path: 'src/lib/lswt/table.ts'
      provides: 'Extracted printTable function importable by both lswt.ts and wt/list.ts'
      exports: ['printWorktreeTable']
    - path: 'src/cli/wt/list.ts'
      provides: 'Direct library call handler for wt list'
      contains: 'gatherWorktreeInfo'
    - path: 'src/cli/wt/state.ts'
      provides: 'Direct library call handler for wt state'
      contains: 'analyzeState'
  key_links:
    - from: 'src/cli/wt/list.ts'
      to: 'src/lib/lswt/index.js'
      via: 'direct import of gatherWorktreeInfo, formatJsonOutput, runInteractiveMode'
      pattern: 'import.*from.*lib/lswt'
    - from: 'src/cli/wt/list.ts'
      to: 'src/lib/lswt/table.js'
      via: 'direct import of printWorktreeTable'
      pattern: 'import.*printWorktreeTable.*from.*table'
    - from: 'src/cli/wt/state.ts'
      to: 'src/lib/wtstate/index.js'
      via: 'direct import of analyzeState, formatText'
      pattern: 'import.*from.*lib/wtstate'
    - from: 'src/cli/lswt.ts'
      to: 'src/lib/lswt/table.js'
      via: 'import of printWorktreeTable replacing local printTable'
      pattern: 'import.*printWorktreeTable.*from.*table'
---

<objective>
Replace `runSubcommand('lswt', args)` in `wt/list.ts` and `runSubcommand('wtstate', args)` in `wt/state.ts` with direct library function calls. Extract the `printTable` function from `lswt.ts` to a shared module so both `lswt.ts` and `wt/list.ts` can import it.

Purpose: Eliminate subprocess spawning for the two simplest wt subcommands, establishing the migration pattern for subsequent plans.
Output: `wt list` and `wt state` call library functions directly in-process; printTable extracted to shared location with tests.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-in-process-delegation/05-RESEARCH.md

@src/cli/wt/list.ts
@src/cli/wt/state.ts
@src/cli/lswt.ts
@src/cli/wtstate.ts
@src/lib/lswt/index.ts
@src/lib/wtstate/index.ts
@src/cli/wt/prs.ts (reference pattern: direct library call in wt handler)
@src/cli/wt.ts (logger initialization, error handling patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract printTable from lswt.ts to shared module and migrate wt/list.ts + wt/state.ts to direct calls</name>
  <files>
    src/lib/lswt/table.ts
    src/lib/lswt/index.ts
    src/cli/lswt.ts
    src/cli/wt/list.ts
    src/cli/wt/state.ts
  </files>
  <action>
**Step 1: Extract printTable to `src/lib/lswt/table.ts`**

Create `src/lib/lswt/table.ts` containing the `printWorktreeTable` function (renamed from `printTable` for clarity). The implementation is the `printTable` function currently at lines 65-103 of `src/cli/lswt.ts`. It depends on:

- `formatTypeLabel`, `getDisplayPath` from `./formatters.js`
- `printTable as sharedPrintTable`, `printStatus`, `changeIndicator` from `../ui/index.js`
- `cyan, green, yellow, red, blue, dim` from `../colors.js`
- `WorktreeDisplay`, `ListOptions` from `./types.js`

The function signature: `export function printWorktreeTable(worktrees: WorktreeDisplay[], options: ListOptions, cwd: string): void`

**Step 2: Update `src/lib/lswt/index.ts`**

Add re-export: `export { printWorktreeTable } from './table.js';`

**Step 3: Update `src/cli/lswt.ts`**

Replace the local `printTable` function with an import from the shared module:

- Remove the local `printTable` function (lines 65-103)
- Add import: `import { printWorktreeTable } from '../lib/lswt/table.js';` (or import from index)
- Update the call site at line 178: change `printTable(worktrees, options, process.cwd())` to `printWorktreeTable(worktrees, options, process.cwd())`

**Step 4: Rewrite `src/cli/wt/list.ts` handler**

Replace the entire handler that builds args and calls `runSubcommand('lswt', args, envOverrides)` with direct library calls. Follow the pattern from `wt/prs.ts`:

```typescript
import {
  gatherWorktreeInfo,
  createDefaultDeps,
  formatJsonOutput,
  runInteractiveMode,
  printWorktreeTable,
} from '../../lib/lswt/index.js';
import * as git from '../../lib/git.js';
import * as github from '../../lib/github.js';
import {
  setJsonMode,
  printStatus,
  printDim,
  printError,
  errorToDisplay,
} from '../../lib/ui/index.js';
import {
  createErrorResult,
  formatJsonResult,
  ErrorCode,
  getErrorSuggestion,
} from '../../lib/json-output.js';
import type { ListOptions } from '../../lib/lswt/index.js';
```

The handler becomes `async (argv) => { ... }`:

1. Build `ListOptions` from argv: `{ verbose: !!argv.verbose, json: !!argv.json, showStatus: !!argv.status, interactive: argv.interactive, noColor: !!argv.noColor, quiet: !!argv.quiet }`
2. Call `setJsonMode(options.json)` for UI gate
3. Check gh CLI if status requested: `if (options.showStatus && !github.isGhInstalled()) { ... }`
4. Get repo root: `const repoRoot = git.getRepoRoot()` with error handling (JSON-aware)
5. Gather worktree info: `const deps = createDefaultDeps(); const worktrees = await gatherWorktreeInfo(repoRoot, options, deps);`
6. Determine interactive mode: `const useInteractive = options.interactive === true || (options.interactive === undefined && process.stdout.isTTY && !options.json);`
7. Output branch: if json → `console.log(formatJsonOutput(worktrees))`, if interactive → `await runInteractiveMode(worktrees, options)`, else → `printWorktreeTable(worktrees, options, process.cwd())`

Remove the `import { runSubcommand }` and all the args-building + envOverrides code.

Important: Do NOT call `initializeLogger()` -- the logger singleton is already initialized by `wt.ts`.
Important: Do NOT call `process.exit()` unless fatal error; let errors propagate to wt.ts `.fail()`/`.catch()` handlers.
For error paths where the user must see the error and exit (e.g., not a git repo), throw an Error that wt.ts will catch, or call `process.exit(1)` as the legacy CLI does. The cleanest approach: for JSON errors output JSON and call process.exit(1); for non-JSON errors use printError and call process.exit(1). This matches how init.ts and config.ts handle errors.

**Step 5: Rewrite `src/cli/wt/state.ts` handler**

Replace the handler with direct library calls:

```typescript
import { analyzeState, formatText } from '../../lib/wtstate/index.js';
import * as git from '../../lib/git.js';
import { setJsonMode, printError } from '../../lib/ui/index.js';
import {
  createSuccessResult,
  createErrorResult,
  formatJsonResult,
  ErrorCode,
  type WtstateResultData,
} from '../../lib/json-output.js';
import type { WtstateOptions } from '../../lib/wtstate/index.js';
```

The handler becomes `async (argv) => { ... }`:

1. Build options: `{ verbose: !!argv.verbose, json: !!argv.json, baseBranch: argv['base-branch'] }`
2. `setJsonMode(options.json)`
3. Check git repo: try `git.getRepoRoot()` catch → error (JSON-aware) + process.exit(1)
4. Call `analyzeState(options)` in try/catch
5. If json: build `WtstateResultData` and output via `createSuccessResult('wtstate', data)` + `formatJsonResult`
6. If text: `console.log(formatText(stateResult, options.verbose))`
7. On error: JSON-aware error output + process.exit(1)

Remove the `import { runSubcommand }` and all args-building code.

Important: Do NOT call `initializeLogger()` -- already done by wt.ts.
</action>
<verify>

1. `npm run build` succeeds without errors
2. `npm test` passes -- all existing tests still pass
3. Grep for `runSubcommand` in `src/cli/wt/list.ts` and `src/cli/wt/state.ts` returns no results
4. Grep for `gatherWorktreeInfo` in `src/cli/wt/list.ts` returns a match
5. Grep for `analyzeState` in `src/cli/wt/state.ts` returns a match
   </verify>
   <done>
   wt/list.ts and wt/state.ts call library functions directly without runSubcommand; printWorktreeTable is importable from src/lib/lswt/table.ts; lswt.ts uses the extracted function; all tests pass.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Add tests for extracted printWorktreeTable and verify no regressions</name>
  <files>
    src/lib/lswt/table.test.ts
  </files>
  <action>
Create `src/lib/lswt/table.test.ts` with tests for the extracted `printWorktreeTable` function:

1. **Empty worktrees**: Verify `printWorktreeTable([], options, cwd)` calls `printStatus('info', 'No worktrees found.')`
2. **Basic worktree list**: Create mock `WorktreeDisplay[]` with 2 entries (one main, one PR), verify the function calls `sharedPrintTable` with expected title, rows, and summary
3. **Verbose mode**: With `options.verbose = true`, verify commit hash appears in the row fields
4. **Changes indicator**: With `hasChanges: true` on a worktree, verify the change indicator appears
5. **Summary counts**: With a mix of PR types and states, verify the summary string includes correct counts (e.g., "3 worktrees · 2 PRs · 1 open")

Mock dependencies: `vi.mock('../ui/index.js')` for `printTable`, `printStatus`, `changeIndicator`. Use `vi.importActual` for types.

Ensure `npm test` passes with the new test file and all existing tests.
</action>
<verify>

1. `npm test -- src/lib/lswt/table.test.ts` passes
2. `npm test` passes (full suite, no regressions)
   </verify>
   <done>
   printWorktreeTable has dedicated test coverage; full test suite passes with no regressions.
   </done>
   </task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. `npm test` passes (full suite)
3. No `runSubcommand` import or call remains in `src/cli/wt/list.ts` or `src/cli/wt/state.ts`
4. `src/lib/lswt/table.ts` exists and exports `printWorktreeTable`
5. `src/cli/lswt.ts` imports `printWorktreeTable` from the shared module (no local `printTable` function)
6. `src/cli/wt/list.ts` imports from `../../lib/lswt/` and `../../lib/wtstate/` (no run-command import)
</verification>

<success_criteria>

- wt list and wt state call library functions directly (gatherWorktreeInfo, analyzeState) without subprocess spawning
- printWorktreeTable is a tested, shared module importable by both lswt.ts and wt/list.ts
- All existing tests pass with no regressions
- Build succeeds on all platforms
  </success_criteria>

<output>
After completion, create `.planning/phases/05-in-process-delegation/05-01-SUMMARY.md`
</output>
