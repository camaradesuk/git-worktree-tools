---
phase: 05-in-process-delegation
plan: 03
type: execute
wave: 2
depends_on: ['05-01', '05-02']
files_modified:
  - src/cli/wt/new.ts
  - src/cli/wt/link.ts
  - src/cli/newpr.ts
autonomous: true

must_haves:
  truths:
    - "Running `wt new 'Add feature'` creates a PR without spawning a child process"
    - 'Running `wt new --pr 42` creates a worktree for existing PR without spawning a child process'
    - "Running `wt new --json -y --action=empty_commit 'Fix'` outputs valid JSON without spawning a child process"
    - 'Running `wt link` shows interactive menu without spawning a child process'
    - 'Running `wt link validate --json` outputs valid JSON without spawning a child process'
    - 'Running `wt link link . ../repo.pr42` creates hard links without spawning a child process'
    - "Running `wt --verbose new 'Feature'` produces debug output from the shared logger singleton"
  artifacts:
    - path: 'src/cli/newpr.ts'
      provides: 'Exported runNewprHandler(options) function callable without re-parsing args'
      exports: ['runNewprHandler']
    - path: 'src/cli/wt/new.ts'
      provides: 'Direct library call handler via runNewprHandler'
      contains: 'runNewprHandler'
    - path: 'src/cli/wt/link.ts'
      provides: 'Direct library call handler for all wtlink subcommands'
      contains: 'no runSubcommand import'
  key_links:
    - from: 'src/cli/wt/new.ts'
      to: 'src/cli/newpr.js'
      via: 'direct import of runNewprHandler'
      pattern: 'import.*runNewprHandler.*from.*newpr'
    - from: 'src/cli/wt/link.ts'
      to: 'src/lib/wtlink/'
      via: 'direct import of manage, link, validate modules'
      pattern: 'import.*from.*lib/wtlink'
---

<objective>
Replace `runSubcommand('newpr', args)` in `wt/new.ts` and `runSubcommand('wtlink', args)` in `wt/link.ts` with direct library function calls. For newpr (1300 lines, HIGH complexity), extract a `runNewprHandler(options)` function from the CLI entry point rather than inlining all logic. For wtlink (MEDIUM-HIGH complexity with its own yargs subcommand structure), map each wtlink subcommand to its corresponding library function call.

Purpose: Complete the migration of all wt subcommand handlers to direct library calls, eliminating the last subprocess spawning paths.
Output: `wt new` and `wt link` call library functions directly in-process.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-in-process-delegation/05-RESEARCH.md
@.planning/phases/05-in-process-delegation/05-01-SUMMARY.md
@.planning/phases/05-in-process-delegation/05-02-SUMMARY.md

@src/cli/wt/new.ts
@src/cli/wt/link.ts
@src/cli/newpr.ts
@src/cli/wtlink.ts
@src/lib/newpr/index.ts
@src/lib/wtlink/link-configs.ts
@src/lib/wtlink/manage-manifest.ts
@src/lib/wtlink/validate-manifest.ts
@src/lib/wtlink/config-manifest.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract runNewprHandler from newpr.ts and migrate wt/new.ts</name>
  <files>
    src/cli/newpr.ts
    src/cli/wt/new.ts
  </files>
  <action>
**Step 1: Extract `runNewprHandler` from `src/cli/newpr.ts`**

The `newpr.ts` file has a `main()` function that:

1. Parses args from `process.argv`
2. Initializes logger
3. Sets JSON mode
4. Calls `checkPrerequisites()`
5. Runs the 3-mode newpr logic (new feature / existing PR / existing branch)

Extract the core logic (steps 4-5 and everything after arg parsing + logger init) into an exported `async function runNewprHandler(options: Options): Promise<void>`.

The function takes an already-parsed `Options` object (from `src/lib/newpr/types.ts`) and runs the full newpr workflow. The existing `main()` function should be refactored to:

1. Parse args
2. Initialize logger (only when run as standalone CLI)
3. Set JSON mode
4. Call `runNewprHandler(parsedOptions)`

The key insight: `newpr.ts` already has an `Options` type that contains all the parsed options. The `parseArgs()` function returns these. The `main()` function just needs to be split at the point where arg parsing ends and business logic begins.

Look at the `main()` function in newpr.ts carefully. After `parseArgs()` succeeds and logger is initialized, the code:

- Calls `checkPrerequisites()`
- Gets repo root, loads config
- Calls `analyzeGitState()` + `detectScenario()`
- Handles scenarios (prompts user, etc.)
- Creates worktree, PR, runs hooks

All of this goes into `runNewprHandler(options)`. The function should NOT call `parseArgs()` or `initializeLogger()` -- those stay in `main()`.

Add `export` to the function: `export async function runNewprHandler(options: Options): Promise<void>`

Keep `main()` as the CLI entry point for standalone `newpr` usage. It now calls `runNewprHandler(parsedOptions)` after parsing args and initializing the logger.

Also export the `Options` type if not already exported from newpr.ts (it's already in `src/lib/newpr/types.ts` and re-exported from `src/lib/newpr/index.ts`).

**Step 2: Rewrite `src/cli/wt/new.ts` handler**

Replace the entire handler with:

```typescript
import { runNewprHandler } from '../newpr.js';
import type { Options } from '../../lib/newpr/index.js';
import { setJsonMode } from '../../lib/ui/index.js';
```

The handler becomes `async (argv) => { ... }`:

1. Build `Options` from argv:
   ```typescript
   const options: Options = {
     description: argv.description,
     pr: argv.pr,
     branch: argv.branch,
     base: argv.base || undefined,
     install: !!argv.install,
     code: !!argv.code,
     ready: !!argv.ready,
     draft: argv.draft,
     noWtlink: !!argv['no-wtlink'],
     noHooks: !!argv['no-hooks'],
     confirmHooks: !!argv['confirm-hooks'],
     plan: argv.plan,
     noPlan: argv['no-plan'],
     json: !!argv.json,
     nonInteractive: !!argv['non-interactive'],
     action: argv.action as Options['action'],
     verbose: !!argv.verbose,
     quiet: !!argv.quiet,
     noColor: !!argv.noColor,
   };
   ```
2. `setJsonMode(options.json)`
3. `await runNewprHandler(options)`

Do NOT call `initializeLogger()` -- already done by wt.ts.

Remove the `import { runSubcommand }` and all the args-building + envOverrides code.

Check the exact `Options` type definition in `src/lib/newpr/types.ts` to make sure the field names match exactly. Map yargs argv field names to Options field names correctly (e.g., `argv['no-wtlink']` maps to `options.noWtlink`, `argv['non-interactive']` maps to `options.nonInteractive`).
</action>
<verify>

1. `npm run build` succeeds
2. `npm test` passes
3. Grep for `runSubcommand` in `src/cli/wt/new.ts` returns no results
4. Grep for `runNewprHandler` in `src/cli/wt/new.ts` returns a match
5. Grep for `export.*runNewprHandler` in `src/cli/newpr.ts` returns a match
   </verify>
   <done>
   newpr.ts exports runNewprHandler; wt/new.ts calls it directly without subprocess spawning; all tests pass.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Migrate wt/link.ts from subprocess to direct library calls</name>
  <files>
    src/cli/wt/link.ts
  </files>
  <action>
The current `wt/link.ts` builds args and calls `runSubcommand('wtlink', args, envOverrides)`. The wtlink CLI has its own yargs subcommand structure with: manage, link, validate, migrate, and default (show main menu).

Replace with direct library calls for each subcommand. Study `src/cli/wtlink.ts` to understand what each subcommand handler does, then replicate the logic.

**New imports** (replace `runSubcommand` import):

```typescript
import * as git from '../../lib/git.js';
import * as colors from '../../lib/colors.js';
import * as manage from '../../lib/wtlink/manage-manifest.js';
import * as link from '../../lib/wtlink/link-configs.js';
import * as validate from '../../lib/wtlink/validate-manifest.js';
import { hasLegacyManifest } from '../../lib/wtlink/config-manifest.js';
import { DEFAULT_MANIFEST_FILE } from '../../lib/constants.js';
import {
  detectMigrationIssues,
  runMigration,
  formatMigrationReport,
} from '../../lib/config-migration/index.js';
import {
  createSuccessResult,
  createErrorResult,
  formatJsonResult,
  ErrorCode,
  getErrorCodeFromError,
} from '../../lib/json-output.js';
import { ManifestError } from '../../lib/errors.js';
import { setJsonMode, isJsonMode, printError } from '../../lib/ui/index.js';
import { showMainMenu } from '../../lib/wtlink/main-menu.js';
```

Check what `showMainMenu` is -- it's the wtlink interactive main menu from `src/lib/wtlink/main-menu.ts`.

**Rewrite the handler** as `async (argv) => { ... }`:

1. `setJsonMode(!!argv.json)`
2. Build common options from argv (manifestFile, json, dryRun, verbose, yes, clean, backup, type, nonInteractive)
3. Get subcommand: `const sub = argv.subcommand || ''`
4. Switch on subcommand:

**No subcommand (default)**: Show interactive main menu

```typescript
if (!sub || sub === '') {
  await showMainMenu();
  return;
}
```

Note: `showMainMenu()` takes zero parameters (confirmed from `src/lib/wtlink/main-menu.ts`). It handles cwd and manifest file resolution internally.

**`manage` subcommand**: Calls manage-manifest interactive TUI

```typescript
case 'manage': {
  const repoRoot = git.getRepoRoot();
  await manage.run({
    cwd: repoRoot,
    manifestFile: argv['manifest-file'] || DEFAULT_MANIFEST_FILE,
    verbose: !!argv.verbose,
    clean: !!argv.clean,
    backup: !!argv.backup,
  });
  return;
}
```

Check the actual `manage.run()` signature in `manage-manifest.ts`.

**`link` subcommand**: Calls link-configs

```typescript
case 'link': {
  const linkArgs = argv.args || [];
  const source = linkArgs[0] || '.';
  const targets = linkArgs.slice(1);
  await link.run({
    source,
    targets,
    manifestFile: argv['manifest-file'] || DEFAULT_MANIFEST_FILE,
    dryRun: !!argv['dry-run'],
    verbose: !!argv.verbose,
    yes: !!argv.yes,
    type: argv.type as 'hard' | 'symbolic' | undefined,
    json: !!argv.json,
    nonInteractive: !!argv['non-interactive'],
  });
  return;
}
```

Check the actual `link.run()` signature in `link-configs.ts`.

**`validate` subcommand**: Calls validate-manifest

```typescript
case 'validate': {
  const repoRoot = git.getRepoRoot();
  const result = await validate.run({
    cwd: repoRoot,
    manifestFile: argv['manifest-file'] || DEFAULT_MANIFEST_FILE,
    json: !!argv.json,
    verbose: !!argv.verbose,
  });
  return;
}
```

Check the actual `validate.run()` signature.

**`migrate` subcommand**: Run config migration

```typescript
case 'migrate': {
  const repoRoot = git.getRepoRoot();
  // Delegate to wt config migrate
  console.log(colors.dim('Note: "wt link migrate" is deprecated. Use "wt config migrate" instead.'));
  // ... run migration logic
  return;
}
```

**Key principle**: Study each subcommand handler in `src/cli/wtlink.ts` to understand the exact function signatures and options passed. Do not guess -- read the actual yargs handler code for each subcommand.

**Error handling**: Wrap the entire handler in try/catch. For `ManifestError`, extract the issues array and display via `printError`. For JSON mode, use `createErrorResult` + `formatJsonResult`. This matches the existing pattern in wtlink.ts's `.fail()` handler.

Remove all `runSubcommand` and `envOverrides` code.

Do NOT call `initializeLogger()` -- already done by wt.ts.
</action>
<verify>

1. `npm run build` succeeds
2. `npm test` passes
3. Grep for `runSubcommand` in `src/cli/wt/link.ts` returns no results
4. Grep for `import.*from.*lib/wtlink` in `src/cli/wt/link.ts` returns matches
   </verify>
   <done>
   wt/link.ts calls wtlink library functions directly for all subcommands; no subprocess spawning; all tests pass.
   </done>
   </task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. `npm test` passes (full suite)
3. No `runSubcommand` import or call remains in `src/cli/wt/new.ts` or `src/cli/wt/link.ts`
4. `src/cli/newpr.ts` exports `runNewprHandler` and standalone `main()` still works
5. Zero `runSubcommand` calls remain in any `src/cli/wt/*.ts` handler file (list, state, clean, config, new, link all migrated)
</verification>

<success_criteria>

- wt new calls runNewprHandler directly without subprocess spawning
- wt link handles all subcommands (manage, link, validate, migrate, default menu) without subprocess spawning
- newpr standalone CLI still works (main() calls runNewprHandler internally)
- All existing tests pass with no regressions
- Zero runSubcommand calls remain in wt subcommand handler files
  </success_criteria>

<output>
After completion, create `.planning/phases/05-in-process-delegation/05-03-SUMMARY.md`
</output>
