---
phase: 05-in-process-delegation
plan: 04
type: execute
wave: 3
depends_on: ['05-01', '05-02', '05-03']
files_modified:
  - src/cli/newpr.ts
  - src/cli/cleanpr.ts
  - src/cli/lswt.ts
  - src/cli/wtlink.ts
  - src/cli/wtstate.ts
  - src/cli/wtconfig.ts
  - src/lib/deprecation.ts
  - src/lib/deprecation.test.ts
  - src/cli/wt/interactive-menu.ts
  - src/cli/wt/interactive-menu.test.ts
  - README.md
autonomous: true

must_haves:
  truths:
    - 'Running `newpr` directly prints a deprecation notice to stderr directing to `wt new`'
    - 'Running `cleanpr` directly prints a deprecation notice to stderr directing to `wt clean`'
    - 'Running `lswt` directly prints a deprecation notice to stderr directing to `wt list`'
    - 'Running `wtlink` directly prints a deprecation notice to stderr directing to `wt link`'
    - 'Running `wtstate` directly prints a deprecation notice to stderr directing to `wt state`'
    - 'Running `wtconfig` directly prints a deprecation notice to stderr directing to `wt config`'
    - 'Deprecation notice is suppressed when GWT_NO_DEPRECATION_WARNINGS=1 is set'
    - 'Deprecation notice is suppressed when --json flag is present (to avoid corrupting JSON output)'
    - 'The wt interactive menu no longer spawns subprocesses for any action'
    - 'README presents `wt` as the canonical entry point with legacy commands listed as deprecated'
  artifacts:
    - path: 'src/lib/deprecation.ts'
      provides: 'Shared deprecation notice utility'
      exports: ['printDeprecationNotice']
    - path: 'src/lib/deprecation.test.ts'
      provides: 'Tests for deprecation notice utility'
    - path: 'README.md'
      provides: 'Updated documentation presenting wt as canonical'
      contains: 'deprecated'
  key_links:
    - from: 'src/cli/newpr.ts'
      to: 'src/lib/deprecation.js'
      via: 'calls printDeprecationNotice at top of main()'
      pattern: 'printDeprecationNotice'
    - from: 'src/cli/wt/interactive-menu.ts'
      to: 'src/lib/*/index.js'
      via: 'direct library function calls replacing runSubcommandForResult'
      pattern: 'no.*runSubcommandForResult'
---

<objective>
Add deprecation notices to all legacy CLI entry points (newpr, cleanpr, lswt, wtlink, wtstate, wtconfig), migrate the interactive menu's remaining `runSubcommandForResult` calls to direct library calls, and update README to present `wt` as the canonical entry point.

Purpose: Complete the UNI-01 (deprecation notices) and UNI-04 (documentation) requirements. Finish the interactive menu migration so zero subprocess calls remain in the wt ecosystem.
Output: All legacy CLIs show deprecation notices; interactive menu uses direct calls; README reflects wt as primary.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-in-process-delegation/05-RESEARCH.md
@.planning/phases/05-in-process-delegation/05-01-SUMMARY.md
@.planning/phases/05-in-process-delegation/05-02-SUMMARY.md
@.planning/phases/05-in-process-delegation/05-03-SUMMARY.md

@src/cli/wt/interactive-menu.ts
@src/cli/wt/interactive-menu.test.ts
@src/cli/newpr.ts
@src/cli/cleanpr.ts
@src/cli/lswt.ts
@src/cli/wtlink.ts
@src/cli/wtstate.ts
@src/cli/wtconfig.ts
@README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared deprecation utility and add notices to all legacy CLI entry points</name>
  <files>
    src/lib/deprecation.ts
    src/lib/deprecation.test.ts
    src/cli/newpr.ts
    src/cli/cleanpr.ts
    src/cli/lswt.ts
    src/cli/wtlink.ts
    src/cli/wtstate.ts
    src/cli/wtconfig.ts
  </files>
  <action>
**Step 1: Create `src/lib/deprecation.ts`**

```typescript
/**
 * Shared deprecation notice utility
 *
 * Prints a stderr deprecation warning for legacy CLI commands.
 * Respects JSON mode and suppression env var.
 */

/**
 * Print a deprecation notice to stderr.
 *
 * Skips output when:
 * - GWT_NO_DEPRECATION_WARNINGS=1 is set
 * - --json flag is present in process.argv (avoids corrupting structured output)
 *
 * @param oldCommand - The deprecated command name (e.g., 'lswt')
 * @param newCommand - The replacement command (e.g., 'wt list')
 */
export function printDeprecationNotice(oldCommand: string, newCommand: string): void {
  // Skip in JSON mode to avoid corrupting structured output
  if (process.argv.includes('--json')) return;

  // Allow suppression via environment variable
  if (process.env.GWT_NO_DEPRECATION_WARNINGS === '1') return;

  process.stderr.write(
    `\x1b[33m[DEPRECATED]\x1b[0m "${oldCommand}" is deprecated. Use "${newCommand}" instead.\n` +
      `This command will be removed in a future version.\n` +
      `Set GWT_NO_DEPRECATION_WARNINGS=1 to suppress this notice.\n\n`
  );
}
```

**Step 2: Create `src/lib/deprecation.test.ts`**

Test the deprecation notice utility:

1. **Normal output**: Calling `printDeprecationNotice('lswt', 'wt list')` writes to stderr containing "[DEPRECATED]" and "lswt" and "wt list"
2. **JSON suppression**: When `process.argv` includes `--json`, no output is written
3. **Env var suppression**: When `GWT_NO_DEPRECATION_WARNINGS=1`, no output is written
4. **Both old and new command appear in message**: Verify the message contains both the deprecated and replacement command names

Mock `process.stderr.write` and `process.argv` appropriately. Save and restore `process.env.GWT_NO_DEPRECATION_WARNINGS` in beforeEach/afterEach.

**Step 3: Add deprecation notice to each legacy CLI**

Add `import { printDeprecationNotice } from '../lib/deprecation.js';` and call it at the very top of the `main()` function (before any other logic) in each file:

- `src/cli/newpr.ts`: `printDeprecationNotice('newpr', 'wt new');` at top of `main()`
- `src/cli/cleanpr.ts`: `printDeprecationNotice('cleanpr', 'wt clean');` at top of `main()`
- `src/cli/lswt.ts`: `printDeprecationNotice('lswt', 'wt list');` at top of `main()`
- `src/cli/wtlink.ts`: Add before yargs parsing begins (at the top of the file's execution, before `yargs(hideBin(process.argv))...`). Since wtlink uses yargs directly (not a main() function), add the call right after the imports, before the yargs chain starts.
- `src/cli/wtstate.ts`: `printDeprecationNotice('wtstate', 'wt state');` at top of `main()`
- `src/cli/wtconfig.ts`: Add before the main execution. Check the file structure -- it may use yargs directly like wtlink.

Place the call BEFORE arg parsing so users see it even if args are invalid.
</action>
<verify>

1. `npm run build` succeeds
2. `npm test` passes
3. `src/lib/deprecation.ts` exists with `printDeprecationNotice` export
4. Grep for `printDeprecationNotice` in all 6 legacy CLI files returns matches
5. `npm test -- src/lib/deprecation.test.ts` passes
   </verify>
   <done>
   Deprecation notice utility created with tests; all 6 legacy CLI entry points call printDeprecationNotice before executing.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Migrate interactive menu runSubcommandForResult calls to direct library calls</name>
  <files>
    src/cli/wt/interactive-menu.ts
    src/cli/wt/interactive-menu.test.ts
  </files>
  <action>
The interactive menu (`interactive-menu.ts`) has ~15 remaining `runSubcommandForResult` calls. Phase 3 already converted wtlink view/add/remove to direct library calls. Now convert the remaining calls.

**New imports** (add alongside existing, remove `runSubcommandForResult` import):

```typescript
// Direct library imports for in-process calls
import {
  gatherWorktreeInfo,
  createDefaultDeps as createLswtDeps,
  formatJsonOutput,
  runInteractiveMode,
  printWorktreeTable,
} from '../../lib/lswt/index.js';
import { runPrsCommand } from '../../lib/prs/command.js';
import { runNewprHandler } from '../newpr.js';
import type { Options as NewprOptions } from '../../lib/newpr/index.js';
import {
  gatherPrWorktreeInfo,
  createDefaultDeps as createCleanprDeps,
  getCleanableWorktrees,
  cleanWorktree,
  summarizeResults,
} from '../../lib/cleanpr/index.js';
import type { CleanOptions } from '../../lib/cleanpr/index.js';
import { analyzeState, formatText } from '../../lib/wtstate/index.js';
import { run as runWtlinkLink } from '../../lib/wtlink/link-configs.js';
import { run as runWtlinkValidate } from '../../lib/wtlink/validate-manifest.js';
import { formatConfigDisplay, loadMergedConfig, setConfigValue } from '../../lib/global-config.js';
```

Check which of these are already imported and only add what's needed.

**Migration for each handler:**

**`handleListWorktrees`** (currently calls `runSubcommandForResult('lswt', [])`):
Replace with direct call. The menu currently spawns lswt with no args, which gives interactive mode. But in the menu context, we probably want non-interactive list output (since we're already in a menu). Check what the current behavior is -- it spawns `lswt` with `[]` args, which defaults to interactive mode in TTY. In the menu context, it should probably run non-interactive table output or the interactive worktree picker.

The simplest migration: call the same library functions that `wt list` uses.

```typescript
async function handleListWorktrees(): Promise<FlowResult> {
  console.log();
  try {
    const repoRoot = git.getRepoRoot();
    const deps = createLswtDeps();
    const worktrees = await gatherWorktreeInfo(
      repoRoot,
      { verbose: false, json: false, showStatus: false },
      deps
    );
    // Run interactive mode (same as standalone lswt with no args)
    await runInteractiveMode(worktrees, { verbose: false, json: false, showStatus: false });
  } catch (error) {
    console.log(red(error instanceof Error ? error.message : String(error)));
  }
  return COMPLETED_RETURN;
}
```

Actually, the current behavior spawns lswt which enters interactive mode. The direct equivalent is `runInteractiveMode`. But there might be a concern about nested interactive sessions (we're already in the wt menu). Check the existing flow -- the lswt subprocess takes over stdio and returns when done, then the menu resumes. With direct calls, `runInteractiveMode` will do the same (raw mode TUI, then cleanup, then return).

**`handleBrowsePRs`** (currently calls `runSubcommandForResult('prs', [])`):

```typescript
async function handleBrowsePRs(): Promise<FlowResult> {
  console.log();
  try {
    await runPrsCommand({ state: 'open', limit: 50, json: false, noInteractive: false });
  } catch (error) {
    console.log(red(error instanceof Error ? error.message : String(error)));
  }
  return COMPLETED_RETURN;
}
```

**`handleNewPR*` (3 flows)** - these build args and call `runSubcommandForResult('newpr', args)`:

For `handleNewPR` (new feature):

```typescript
// Build Options object from the gathered inputs
const options: Partial<NewprOptions> = {
  description: description,
  install: installDeps,
  code: openInEditor,
  ready: prType === 'ready',
  draft: prType === 'draft' ? true : undefined,
};
await runNewprHandler(options as NewprOptions);
```

For `handleNewPRExisting` (existing PR):

```typescript
const options: Partial<NewprOptions> = {
  pr: prNumber,
  install: installDeps,
  code: openInEditor,
};
await runNewprHandler(options as NewprOptions);
```

For `handleNewPRBranch` (existing branch):

```typescript
const options: Partial<NewprOptions> = {
  branch: branchName,
  install: installDeps,
  code: openInEditor,
  ready: prType === 'ready',
  draft: prType === 'draft' ? true : undefined,
};
await runNewprHandler(options as NewprOptions);
```

Check the exact `Options` type to ensure all required fields have defaults. The `runNewprHandler` should handle missing fields gracefully (using defaults from config).

**`handleCleanPRs` (3 paths: clean-all, clean-specific, dry-run)**:

For clean-all:

```typescript
const repoRoot = git.getRepoRoot();
const config = loadConfig(repoRoot);
const deps = createCleanprDeps();
const worktrees = await gatherPrWorktreeInfo(repoRoot, config.worktreePattern, deps);
const cleanable = getCleanableWorktrees(worktrees);
// ... clean each one, display results
```

For clean-specific (PR number):

```typescript
// Similar but targets a specific PR
```

For dry-run:

```typescript
// Similar but with dryRun: true
```

These are more involved. The cleanpr CLI has significant orchestration. Since `wt clean` handler (from 05-02) now has all this logic inline, consider extracting a shared function or just inlining the essential logic.

A pragmatic approach: Create a small helper that captures the common cleanpr flow:

```typescript
async function runCleanPrs(options: {
  all?: boolean;
  prNumber?: number;
  dryRun?: boolean;
}): Promise<void> {
  // Inline the essential cleanpr logic from the wt/clean.ts handler
}
```

**`handleShowState`** (calls `runSubcommandForResult('wtstate', [])`):

```typescript
async function handleShowState(): Promise<FlowResult> {
  console.log();
  try {
    const stateResult = analyzeState({ verbose: false, json: false });
    console.log(formatText(stateResult, false));
  } catch (error) {
    console.log(red(error instanceof Error ? error.message : String(error)));
  }
  return COMPLETED_RETURN;
}
```

**`handleConfigure` paths (view, init, edit-setting)**:

For `view` (calls `runSubcommandForResult('wtconfig', ['show'])`):

```typescript
case 'view': {
  console.log();
  const repoRoot = git.getRepoRoot();
  console.log(formatConfigDisplay(repoRoot));
  break;
}
```

For `init` (calls `runSubcommandForResult('wtconfig', ['init'])`):

```typescript
case 'init': {
  // This runs the interactive init wizard
  // Import and call the appropriate init function
  console.log();
  // The simplest approach: call the wtconfig init logic directly
  // Check what wtconfig init does and replicate
  break;
}
```

For `edit-setting` (calls `runSubcommandForResult('wtconfig', ['set', setting, value])`):

```typescript
case 'edit-setting': {
  const repoRoot = git.getRepoRoot();
  setConfigValue(repoRoot, setting, value);
  console.log(colors.success(`Set ${setting} = ${value}`));
  break;
}
```

**`handleLinkConfig` remaining paths (sync, validate)**:

For `sync` (calls `runSubcommandForResult('wtlink', ['link'])`):

```typescript
case 'sync': {
  console.log();
  try {
    await runWtlinkLink({ source: '.', targets: [], manifestFile: DEFAULT_MANIFEST_FILE, json: false });
  } catch (error) {
    console.log(red(error instanceof Error ? error.message : String(error)));
  }
  break;
}
```

For `validate` (calls `runSubcommandForResult('wtlink', ['validate'])`):

```typescript
case 'validate': {
  console.log();
  try {
    await runWtlinkValidate({ cwd: git.getRepoRoot(), manifestFile: DEFAULT_MANIFEST_FILE, json: false });
  } catch (error) {
    console.log(red(error instanceof Error ? error.message : String(error)));
  }
  break;
}
```

Check the actual function signatures by reading the library files. The function names and signatures must match exactly.

**Update `src/cli/wt/interactive-menu.test.ts`**:

- Remove the mock for `runSubcommandForResult` from `./run-command.js`
- Add mocks for the new direct library imports
- Update test expectations: instead of verifying `runSubcommandForResult` was called with args, verify the direct library functions were called with the correct options
- This is a significant test update since ~40 test assertions reference `runSubcommandForResult`

The key test pattern changes:

- `expect(runSubcommandForResult).toHaveBeenCalledWith('lswt', [])` becomes verifying the library function was called
- `expect(runSubcommandForResult).toHaveBeenCalledWith('newpr', ['Add dark mode'])` becomes verifying `runNewprHandler` was called with appropriate options
- etc.

**Remove the `runSubcommandForResult` import** from interactive-menu.ts.
</action>
<verify>

1. `npm run build` succeeds
2. `npm test` passes
3. Grep for `runSubcommandForResult` in `src/cli/wt/interactive-menu.ts` returns no results
4. `npm test -- src/cli/wt/interactive-menu.test.ts` passes
   </verify>
   <done>
   Interactive menu uses direct library calls for all operations; no subprocess spawning; tests updated for direct call verification.
   </done>
   </task>

<task type="auto">
  <name>Task 3: Update README to present wt as canonical entry point with legacy commands as deprecated</name>
  <files>
    README.md
  </files>
  <action>
Update README.md to reflect `wt` as the primary CLI. Changes:

1. **Commands Reference section**: Currently headings show "wt new / newpr", "wt list / lswt", etc. Change to:
   - "wt new" (remove "/ newpr")
   - "wt list" (remove "/ lswt")
   - "wt clean" (remove "/ cleanpr")
   - etc.

2. **Add a "Legacy Commands" section** after the Commands Reference:

````markdown
## Legacy Commands (Deprecated)

The following standalone commands are deprecated and will be removed in a future version.
Use the `wt` equivalents instead:

| Legacy Command | Replacement | Notes                       |
| -------------- | ----------- | --------------------------- |
| `newpr`        | `wt new`    | Same options, same behavior |
| `cleanpr`      | `wt clean`  | Same options, same behavior |
| `lswt`         | `wt list`   | Same options, same behavior |
| `wtlink`       | `wt link`   | Same options, same behavior |
| `wtstate`      | `wt state`  | Same options, same behavior |
| `wtconfig`     | `wt config` | Same options, same behavior |

Legacy commands show a deprecation notice on stderr. Suppress with:

```bash
export GWT_NO_DEPRECATION_WARNINGS=1
```
````

```

3. **Global Options section** (around line 95-101): Remove `--debug` and `--log-file FILE` if they are still listed (these were removed in Phase 1). The correct options are:
```

wt -v, --verbose # Verbose output (debug level)
wt -q, --quiet # Suppress non-essential output
wt --no-color # Disable colored output
wt --json # JSON output (where supported)

```

4. **Quick Start section**: Already uses `wt` commands -- verify no legacy command references remain.

5. **Any remaining references** to standalone `newpr`, `cleanpr`, `lswt`, `wtlink` as primary commands should be updated to reference `wt new`, `wt clean`, `wt list`, `wt link` respectively. Legacy names can appear in the deprecation section only.

6. **MCP section** (if it exists): Should reference `wt` commands in examples.

Read the full README to find all instances that need updating. Use grep for `newpr`, `cleanpr`, `lswt`, `wtlink`, `wtstate`, `wtconfig` to find all references.
</action>
<verify>
1. README.md mentions "deprecated" in the context of legacy commands
2. README.md has a Legacy Commands section with the deprecation table
3. The main Commands Reference headings use `wt` prefix without legacy aliases
4. Global Options section does not reference `--debug` or `--log-file`
</verify>
<done>
README presents wt as canonical entry point; legacy commands documented as deprecated with migration table; no stale flag references.
</done>
</task>

</tasks>

<verification>
1. `npm run build` compiles without errors
2. `npm test` passes (full suite)
3. All 6 legacy CLIs (`newpr`, `cleanpr`, `lswt`, `wtlink`, `wtstate`, `wtconfig`) contain `printDeprecationNotice` calls
4. Zero `runSubcommandForResult` calls remain in `interactive-menu.ts`
5. Zero `runSubcommand` or `runSubcommandForResult` calls remain in any `src/cli/wt/*.ts` file (except `run-command.ts` itself which defines them)
6. README has a "Legacy Commands (Deprecated)" section
7. Deprecation notice is suppressible via `GWT_NO_DEPRECATION_WARNINGS=1`
</verification>

<success_criteria>
- All legacy CLI entry points show deprecation notices directing to wt equivalents
- Interactive menu operates entirely via direct library calls (zero subprocess spawning)
- README presents wt as the canonical entry point
- Deprecation notices respect --json (no corruption) and GWT_NO_DEPRECATION_WARNINGS env var
- All tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-in-process-delegation/05-04-SUMMARY.md`
</output>
```
