---
phase: 03-interactive-menu-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/wt/interactive-menu.ts
  - src/cli/wt/interactive-menu.test.ts
  - src/lib/wtlink/config-manifest.ts
autonomous: true

must_haves:
  truths:
    - 'Selecting any action in the wt interactive menu completes the action and returns to the main menu instead of terminating the process'
    - 'All wtlink menu actions (view, sync, add, remove, validate) invoke code that exists and completes without error'
    - 'Non-zero exit codes from subcommands display a brief error message and return to the menu'
  artifacts:
    - path: 'src/cli/wt/interactive-menu.ts'
      provides: 'Menu handlers that return to menu loop after subcommand execution'
      contains: 'runSubcommandForResult'
    - path: 'src/cli/wt/interactive-menu.test.ts'
      provides: 'Tests verifying return-to-menu behavior and wtlink library call integration'
      contains: 'returnToMenu: true'
  key_links:
    - from: 'src/cli/wt/interactive-menu.ts'
      to: 'src/cli/wt/run-command.ts'
      via: 'runSubcommandForResult import'
      pattern: 'runSubcommandForResult'
    - from: 'src/cli/wt/interactive-menu.ts'
      to: 'src/lib/wtlink/config-manifest.ts'
      via: 'loadManifestData/saveManifestData imports for view/add/remove'
      pattern: 'loadManifestData|saveManifestData'
---

<objective>
Fix the two most critical interactive menu bugs: (1) every menu action terminates the process instead of returning to the menu loop (MENU-02), and (2) four wtlink menu actions invoke non-existent subcommands (MENU-01).

Purpose: The `wt` interactive menu is currently unusable as a menu — every action kills the process. After this plan, selecting any action completes it and returns to the main menu. The four broken wtlink actions (view, sync, add, remove) now invoke real code.

Output: Updated `interactive-menu.ts` with all `runSubcommand()` calls replaced by `runSubcommandForResult()` and wtlink actions rewired to library calls; updated tests validating return-to-menu behavior.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-interactive-menu-reliability/03-RESEARCH.md
@src/cli/wt/interactive-menu.ts
@src/cli/wt/run-command.ts
@src/cli/wt/interactive-menu.test.ts
@src/lib/wtlink/config-manifest.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace runSubcommand with runSubcommandForResult and rewire wtlink actions</name>
  <files>src/cli/wt/interactive-menu.ts</files>
  <action>
Replace all 17 `runSubcommand()` calls with `runSubcommandForResult()` and rewire the 4 broken wtlink actions to use direct library calls. Specific changes:

**Import changes (top of file):**

- Change `import { runSubcommand } from './run-command.js'` to `import { runSubcommandForResult } from './run-command.js'`
- Add import: `import { loadManifestData, saveManifestData } from '../../lib/wtlink/config-manifest.js'`
- Add import: `import { dim as dimColor } from '../../lib/colors.js'` (already imported as `dim`, verify)

**For ALL 13 working subcommand calls** (lswt, prs, newpr x3, cleanpr x3, wtstate, wtconfig x3, wtlink validate):
Replace the pattern:

```typescript
runSubcommand('xxx', args);
return COMPLETED_EXIT;
```

with:

```typescript
const result = runSubcommandForResult('xxx', args);
if (result.status !== 0) {
  console.log(red(`Command exited with code ${result.status}`));
}
return { completed: true, returnToMenu: true };
```

**For wtlink 'view' action** (was `runSubcommand('wtlink', ['list'])`):
Replace with direct library call:

```typescript
case 'view': {
  console.log();
  try {
    const repoRoot = git.getRepoRoot();
    const manifest = loadManifestData(repoRoot);
    if (manifest.enabled.length === 0 && manifest.disabled.length === 0) {
      console.log(dim('No files in link manifest.'));
      console.log(dim('Use "Add file to manifest" to start linking files.'));
    } else {
      if (manifest.enabled.length > 0) {
        console.log(bold('Enabled (actively linked):'));
        for (const f of manifest.enabled) {
          console.log(`  ${f}`);
        }
      }
      if (manifest.disabled.length > 0) {
        if (manifest.enabled.length > 0) console.log();
        console.log(bold('Disabled (tracked but not linked):'));
        for (const f of manifest.disabled) {
          console.log(`  ${dim(f)}`);
        }
      }
      console.log();
      console.log(dim(`Source: ${manifest.source}`));
    }
  } catch {
    console.log(red('Not in a git repository'));
  }
  return { completed: true, returnToMenu: true };
}
```

**For wtlink 'sync' action** (was `runSubcommand('wtlink', ['sync'])`):
Map to the correct subcommand `link` (which creates hard links from manifest):

```typescript
case 'sync': {
  console.log();
  const result = runSubcommandForResult('wtlink', ['link']);
  if (result.status !== 0) {
    console.log(red(`Link sync failed (exit code ${result.status})`));
  }
  return { completed: true, returnToMenu: true };
}
```

**For wtlink 'add' action** (was `runSubcommand('wtlink', ['add', filePath])`):
Replace with direct library call:

```typescript
case 'add': {
  const filePath = await promptInput('File path to add (relative to repo root)');
  if (!filePath) {
    console.log(red('File path is required'));
    return CANCELLED;
  }
  console.log();
  try {
    const repoRoot = git.getRepoRoot();
    const manifest = loadManifestData(repoRoot);
    if (manifest.enabled.includes(filePath)) {
      console.log(dim(`"${filePath}" is already in the manifest.`));
    } else {
      const newEnabled = [...manifest.enabled, filePath];
      saveManifestData(repoRoot, newEnabled, manifest.disabled);
      console.log(`Added "${filePath}" to link manifest.`);
      console.log(dim('Run "Sync links" to create hard links.'));
    }
  } catch {
    console.log(red('Not in a git repository'));
  }
  return { completed: true, returnToMenu: true };
}
```

**For wtlink 'remove' action** (was `runSubcommand('wtlink', ['remove', filePath])`):
Replace with direct library call:

```typescript
case 'remove': {
  const filePath = await promptInput('File path to remove');
  if (!filePath) {
    console.log(red('File path is required'));
    return CANCELLED;
  }
  console.log();
  try {
    const repoRoot = git.getRepoRoot();
    const manifest = loadManifestData(repoRoot);
    const inEnabled = manifest.enabled.includes(filePath);
    const inDisabled = manifest.disabled.includes(filePath);
    if (!inEnabled && !inDisabled) {
      console.log(dim(`"${filePath}" is not in the manifest.`));
    } else {
      const newEnabled = manifest.enabled.filter(f => f !== filePath);
      const newDisabled = manifest.disabled.filter(f => f !== filePath);
      saveManifestData(repoRoot, newEnabled, newDisabled);
      console.log(`Removed "${filePath}" from link manifest.`);
    }
  } catch {
    console.log(red('Not in a git repository'));
  }
  return { completed: true, returnToMenu: true };
}
```

**Remove the `COMPLETED_EXIT` constant** — it is now dead code. All flows return `{ completed: true, returnToMenu: true }`. (If COMPLETED_EXIT is still exported, keep it but it should no longer be used.)

**Important:** Do NOT change the `showMainMenu()` loop logic, the `CANCELLED` constant, or the error handling patterns. Only change what happens after a subcommand runs (return to menu instead of exit).
</action>
<verify>Run `npm run build` — no TypeScript errors. Verify the import of `runSubcommandForResult` (not `runSubcommand`) in interactive-menu.ts. Verify `loadManifestData` and `saveManifestData` are imported. Grep for any remaining `runSubcommand(` calls (should find zero in interactive-menu.ts; `runSubcommandForResult(` should appear 14 times).</verify>
<done>All 17 original `runSubcommand()` calls in interactive-menu.ts are replaced: 13 use `runSubcommandForResult()` with return-to-menu, 4 wtlink actions use direct library calls. No calls to `runSubcommand` (the process-exiting version) remain in interactive-menu.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Update tests for return-to-menu behavior and wtlink library calls</name>
  <files>src/cli/wt/interactive-menu.test.ts</files>
  <action>
Update the test file to reflect the new behavior. Key changes:

**Update the run-command mock** to mock `runSubcommandForResult` instead of `runSubcommand`:

```typescript
vi.mock('./run-command.js', () => ({
  runSubcommandForResult: vi.fn(() => ({
    status: 0,
    stdout: Buffer.from(''),
    stderr: Buffer.from(''),
    pid: 0,
    output: [null, null, null],
    signal: null,
  })),
}));
```

**Add wtlink config-manifest mock:**

```typescript
vi.mock('../../lib/wtlink/config-manifest.js', () => ({
  loadManifestData: vi.fn(() => ({
    enabled: ['.env', '.env.local'],
    disabled: ['config.json'],
    source: 'config',
  })),
  saveManifestData: vi.fn(),
}));
```

Import the new mocked modules:

```typescript
import { runSubcommandForResult } from './run-command.js';
import { loadManifestData, saveManifestData } from '../../lib/wtlink/config-manifest.js';
```

**Update ALL existing tests that check `runSubcommand` to check `runSubcommandForResult` instead:**

- `expect(runSubcommand).toHaveBeenCalledWith(...)` becomes `expect(runSubcommandForResult).toHaveBeenCalledWith(...)`
- Remove ALL `try { ... } catch { // Expected }` wrappers around flow calls — `runSubcommandForResult` no longer throws

**Update tests that verify COMPLETED_EXIT to verify return-to-menu:**

- Tests that previously couldn't check the return value (because runSubcommand threw) should now assert: `expect(result).toEqual({ completed: true, returnToMenu: true })`
- Tests like "calls lswt subcommand with no args" should now get the result: `const result = await flows.handleListWorktrees(); expect(result).toEqual({ completed: true, returnToMenu: true });`

**Add new tests for return-to-menu on error:**

```typescript
it('returns to menu with error message when subcommand fails', async () => {
  vi.mocked(runSubcommandForResult).mockReturnValueOnce({
    status: 1,
    stdout: Buffer.from(''),
    stderr: Buffer.from(''),
    pid: 0,
    output: [null, null, null],
    signal: null,
  });
  const result = await flows.handleListWorktrees();
  expect(result).toEqual({ completed: true, returnToMenu: true });
  expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('exit'));
});
```

**Add new tests for wtlink library call actions:**

```typescript
describe('handleLinkConfig - view via library', () => {
  it('displays manifest contents from loadManifestData', async () => {
    vi.mocked(promptChoice).mockResolvedValueOnce('view');
    const result = await flows.handleLinkConfig();
    expect(loadManifestData).toHaveBeenCalled();
    expect(result).toEqual({ completed: true, returnToMenu: true });
  });

  it('shows empty message when manifest has no files', async () => {
    vi.mocked(loadManifestData).mockReturnValueOnce({ enabled: [], disabled: [], source: 'empty' });
    vi.mocked(promptChoice).mockResolvedValueOnce('view');
    const result = await flows.handleLinkConfig();
    expect(result).toEqual({ completed: true, returnToMenu: true });
    expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('No files'));
  });
});

describe('handleLinkConfig - add via library', () => {
  it('adds file to manifest via saveManifestData', async () => {
    vi.mocked(promptChoice).mockResolvedValueOnce('add');
    vi.mocked(promptInput).mockResolvedValueOnce('.npmrc');
    const result = await flows.handleLinkConfig();
    expect(saveManifestData).toHaveBeenCalledWith(
      '/mock/repo',
      ['.env', '.env.local', '.npmrc'],
      ['config.json']
    );
    expect(result).toEqual({ completed: true, returnToMenu: true });
  });

  it('skips duplicate files', async () => {
    vi.mocked(promptChoice).mockResolvedValueOnce('add');
    vi.mocked(promptInput).mockResolvedValueOnce('.env');
    const result = await flows.handleLinkConfig();
    expect(saveManifestData).not.toHaveBeenCalled();
    expect(result).toEqual({ completed: true, returnToMenu: true });
  });
});

describe('handleLinkConfig - remove via library', () => {
  it('removes file from manifest via saveManifestData', async () => {
    vi.mocked(promptChoice).mockResolvedValueOnce('remove');
    vi.mocked(promptInput).mockResolvedValueOnce('.env');
    const result = await flows.handleLinkConfig();
    expect(saveManifestData).toHaveBeenCalledWith('/mock/repo', ['.env.local'], ['config.json']);
    expect(result).toEqual({ completed: true, returnToMenu: true });
  });

  it('handles file not in manifest', async () => {
    vi.mocked(promptChoice).mockResolvedValueOnce('remove');
    vi.mocked(promptInput).mockResolvedValueOnce('nonexistent.txt');
    const result = await flows.handleLinkConfig();
    expect(saveManifestData).not.toHaveBeenCalled();
    expect(result).toEqual({ completed: true, returnToMenu: true });
  });
});

describe('handleLinkConfig - sync via wtlink link', () => {
  it('calls wtlink link subcommand', async () => {
    vi.mocked(promptChoice).mockResolvedValueOnce('sync');
    const result = await flows.handleLinkConfig();
    expect(runSubcommandForResult).toHaveBeenCalledWith('wtlink', ['link']);
    expect(result).toEqual({ completed: true, returnToMenu: true });
  });
});
```

**Update the showMainMenu return-to-menu test:**
The existing test "returns to menu when flow returns returnToMenu=true" should still work since subcommand actions now return `{ completed: true, returnToMenu: true }`. But the test for "handles list worktrees selection" should now verify return-to-menu instead of expecting a throw:

```typescript
it('handles list worktrees and returns to menu', async () => {
  vi.mocked(promptChoice)
    .mockResolvedValueOnce('list') // Select list
    .mockResolvedValueOnce('exit'); // Then exit
  await showMainMenu();
  expect(runSubcommandForResult).toHaveBeenCalledWith('lswt', []);
  expect(promptChoice).toHaveBeenCalledTimes(2);
});
```

  </action>
  <verify>Run `npm test -- src/cli/wt/interactive-menu.test.ts` — all tests pass. No remaining references to the old `runSubcommand` mock (should be `runSubcommandForResult` everywhere). Run `npm test` for full suite to ensure no regressions.</verify>
  <done>All interactive-menu tests pass. Tests verify: (a) subcommand calls use `runSubcommandForResult`, (b) all flows return `{ completed: true, returnToMenu: true }`, (c) non-zero exit codes produce error messages, (d) wtlink view/add/remove use `loadManifestData`/`saveManifestData`, (e) wtlink sync maps to `wtlink link`, (f) showMainMenu loops back after subcommand completion.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no TypeScript errors
2. `npm test -- src/cli/wt/interactive-menu.test.ts` — all tests pass
3. `npm test` — full test suite passes, no regressions
4. Grep `interactive-menu.ts` for `runSubcommand(` — should find ZERO occurrences of the process-exiting version (only `runSubcommandForResult`)
5. Grep `interactive-menu.ts` for `COMPLETED_EXIT` — should find zero usages (constant may still be defined but unused)
6. Grep `interactive-menu.ts` for `loadManifestData` — should find imports and usages in view/add/remove handlers
</verification>

<success_criteria>

- Every menu action in interactive-menu.ts returns to the menu loop instead of terminating the process
- All 4 broken wtlink actions (view, sync, add, remove) now invoke real, working code
- The validate action still works via `runSubcommandForResult('wtlink', ['validate'])`
- Failed subcommands display a brief error and return to menu
- All existing and new tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/03-interactive-menu-reliability/03-01-SUMMARY.md`
</output>
