---
phase: 03-interactive-menu-reliability
plan: 03
type: execute
wave: 2
depends_on: ['03-01']
files_modified:
  - src/cli/wt.ts
  - src/lib/prs/interactive.ts
  - src/lib/prs/interactive.test.ts
autonomous: true

must_haves:
  truths:
    - 'Pressing Ctrl+C in any interactive mode restores the terminal to a usable state with visible cursor and echo enabled'
    - 'The prs interactive browser handles Ctrl+C via a proper SIGINT handler instead of calling process.exit directly'
    - 'A global exit handler in wt.ts ensures cursor visibility and raw mode reset regardless of how the process exits'
  artifacts:
    - path: 'src/cli/wt.ts'
      provides: 'Global process.on exit handler that restores terminal state'
      contains: 'process.on.*exit'
    - path: 'src/lib/prs/interactive.ts'
      provides: 'SIGINT/SIGTERM handlers following lswt/interactive.ts gold standard pattern'
      contains: 'process.on.*SIGINT'
  key_links:
    - from: 'src/cli/wt.ts'
      to: 'process.stdin'
      via: "process.on('exit') safety net for raw mode"
      pattern: 'setRawMode.*false'
    - from: 'src/lib/prs/interactive.ts'
      to: 'process signal handlers'
      via: 'SIGINT/SIGTERM handler registration'
      pattern: "process\\.on.*SIGINT"
---

<objective>
Add a global terminal state safety net in `wt.ts` and fix Ctrl+C handling in `prs/interactive.ts` to follow the lswt gold standard pattern (MENU-04).

Purpose: Currently, if a user presses Ctrl+C while in raw mode, the terminal may be left in a corrupted state (invisible cursor, no echo). The prs interactive browser calls `process.exit(0)` directly on Ctrl+C instead of cleaning up and resolving. After this plan, Ctrl+C always restores the terminal cleanly, and a global safety net catches any exit path that misses cleanup.

Output: Updated `wt.ts` with global exit handler, updated `prs/interactive.ts` with proper SIGINT handling.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-interactive-menu-reliability/03-RESEARCH.md
@src/cli/wt.ts
@src/lib/prs/interactive.ts
@src/lib/lswt/interactive.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add global terminal state safety net in wt.ts and fix prs Ctrl+C handling</name>
  <files>src/cli/wt.ts, src/lib/prs/interactive.ts</files>
  <action>
**In `src/cli/wt.ts`** — Add a global `process.on('exit')` handler near the top of the file, after imports but before the `initializeLoggerFromCliFlags` function. This is a defensive safety net that ensures terminal state is restored regardless of how the process exits:

```typescript
// Global terminal state safety net
// Ensures raw mode is disabled and cursor is visible on ANY exit path
// This catches crashes, unhandled rejections, and any exit that bypasses cleanup
process.on('exit', () => {
  try {
    // Restore cursor visibility (in case a spinner or render hid it)
    process.stdout.write('\x1b[?25h');
    // Disable raw mode if it was left enabled
    if (process.stdin.isTTY && process.stdin.isRaw) {
      process.stdin.setRawMode(false);
    }
  } catch {
    // Best-effort cleanup — ignore errors during exit
  }
});
```

Place this after the imports and before `initializeLoggerFromCliFlags()`. The `process.on('exit')` handler runs synchronously and cannot be async, so this uses try/catch with no await.

**In `src/lib/prs/interactive.ts`** — Fix the Ctrl+C handling to follow the `lswt/interactive.ts` gold standard pattern. Currently, on Ctrl+C the code calls `process.exit(0)` directly (line ~302). Change it to:

1. **Add SIGINT/SIGTERM handlers** after raw mode is enabled (after `process.stdin.setRawMode(true)` around line 287):

```typescript
// Signal handler to ensure terminal is restored on unexpected termination
const handleSignal = () => {
  cleanup();
  process.exit(0);
};
process.on('SIGINT', handleSignal);
process.on('SIGTERM', handleSignal);
```

2. **Update the cleanup function** to also remove signal handlers (around line 290):

```typescript
const cleanup = () => {
  process.removeListener('SIGINT', handleSignal);
  process.removeListener('SIGTERM', handleSignal);
  process.stdin.setRawMode(false);
  process.stdin.removeListener('data', onKeypress);
  process.stdin.pause();
};
```

3. **Fix the Ctrl+C keypress handler** (around line 300-303) to cleanup and resolve instead of calling process.exit:

Change:

```typescript
if (char === '\x03') {
  cleanup();
  process.exit(0);
}
```

To:

```typescript
if (char === '\x03') {
  cleanup();
  resolve({ pr: null, action: null });
  return;
}
```

This matches how `lswt/interactive.ts` handles Ctrl+C — cleanup, then resolve the promise so the caller can handle the exit gracefully. The caller (the while loop in `runPrInteractiveMode`) already handles `action === null` by exiting the loop.

4. **Add cursor show to cleanup** — add `process.stdout.write('\x1b[?25h')` at the start of the cleanup function, before setRawMode(false), to ensure cursor is visible even if a render hid it.

**Do NOT modify `lswt/interactive.ts`** — it already uses the correct pattern.
**Do NOT modify `lib/wtlink/manage-manifest.ts`** — per project decision, it is treated as a black box.
**Do NOT modify `lib/prompts.ts`** — its Ctrl+C handling via `throw new Error('User cancelled')` is correct for its use case.
</action>
<verify>Run `npm run build` — no TypeScript errors. Read the updated `prs/interactive.ts` to verify: (a) SIGINT handler is registered, (b) cleanup removes SIGINT handler, (c) Ctrl+C resolves instead of calling process.exit, (d) cursor show escape sequence in cleanup. Read `wt.ts` to verify the global exit handler exists with cursor show and raw mode disable.</verify>
<done>The global exit handler in `wt.ts` restores cursor visibility and raw mode on every exit path. The `prs/interactive.ts` Ctrl+C handler follows the lswt gold standard: SIGINT registered, cleanup removes handlers, Ctrl+C resolves the promise instead of killing the process.</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for terminal cleanup behavior</name>
  <files>src/lib/prs/interactive.test.ts</files>
  <action>
Add test cases to the existing `src/lib/prs/interactive.test.ts` (or create it if it does not exist) that verify the Ctrl+C handling improvements.

**Find and read the existing test file first.** If `src/lib/prs/interactive.test.ts` does not exist, check for tests in the prs directory: `ls src/lib/prs/*.test.ts`. If no test file exists, create one.

**Required test cases:**

1. **Ctrl+C resolves with null result (not process.exit):**
   - Mock `process.stdin` as a TTY with raw mode support
   - Set up the `selectPrWithShortcuts` function (or the main interactive mode)
   - Simulate a Ctrl+C keypress (`\x03`)
   - Verify the promise resolves with `{ pr: null, action: null }`
   - Verify `process.exit` was NOT called

2. **Cleanup restores raw mode on Ctrl+C:**
   - Mock `process.stdin.setRawMode`
   - Simulate Ctrl+C
   - Verify `setRawMode(false)` was called

3. **SIGINT handler is registered when raw mode starts:**
   - Spy on `process.on('SIGINT', ...)`
   - Verify it was called during interactive mode setup

4. **SIGINT handler is removed during cleanup:**
   - Spy on `process.removeListener('SIGINT', ...)`
   - Simulate normal exit
   - Verify the handler was removed

**Test approach:** Since `prs/interactive.ts` uses raw mode on `process.stdin`, the tests need to mock stdin. Follow the pattern from `lswt/interactive.test.ts` if it exists, or create mocks:

```typescript
// Mock stdin as a TTY EventEmitter
const mockStdin = {
  isTTY: true,
  isRaw: false,
  setRawMode: vi.fn((mode: boolean) => {
    mockStdin.isRaw = mode;
  }),
  resume: vi.fn(),
  pause: vi.fn(),
  on: vi.fn(),
  removeListener: vi.fn(),
};
```

If the interactive mode is difficult to test in isolation (due to the raw mode + keypress event loop), focus on testing the exported `selectPrWithShortcuts` or whichever function directly handles raw mode, and verify the cleanup semantics at the function level.

**Do NOT create PTY tests** — those are fragile and skip on CI. Use mock-based unit tests only.

**Note:** If the existing test file already has Ctrl+C tests, update them to verify the new behavior (resolve instead of process.exit). Do not duplicate tests.
</action>
<verify>Run `npm test -- src/lib/prs/interactive.test.ts` or the relevant test file — all tests pass. Run `npm test` — full suite passes with no regressions.</verify>
<done>Tests verify: (a) Ctrl+C resolves the promise instead of calling process.exit, (b) raw mode is restored on cleanup, (c) SIGINT handlers are registered and removed properly, (d) cursor visibility is restored.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no TypeScript errors
2. `npm test` — full test suite passes, no regressions
3. Read `src/cli/wt.ts` — global `process.on('exit')` handler exists with cursor show (`\x1b[?25h`) and `setRawMode(false)`
4. Read `src/lib/prs/interactive.ts` — SIGINT handler registered, cleanup removes it, Ctrl+C resolves instead of `process.exit(0)`
5. Grep `prs/interactive.ts` for `process.exit` — should NOT appear in the Ctrl+C keypress handler (may still appear in prerequisite checks which is fine)
</verification>

<success_criteria>

- Pressing Ctrl+C in the prs interactive browser cleanly exits to the caller instead of killing the process
- The `wt.ts` global exit handler ensures cursor is visible and raw mode is off on every exit path
- SIGINT/SIGTERM handlers in prs/interactive.ts follow the lswt/interactive.ts gold standard pattern
- All tests pass including new terminal cleanup tests
  </success_criteria>

<output>
After completion, create `.planning/phases/03-interactive-menu-reliability/03-03-SUMMARY.md`
</output>
