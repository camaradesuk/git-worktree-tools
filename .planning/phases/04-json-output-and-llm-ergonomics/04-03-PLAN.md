---
phase: 04-json-output-and-llm-ergonomics
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcp/server.ts
  - src/mcp/server.test.ts
autonomous: true

must_haves:
  truths:
    - 'Every MCP tool definition includes an `annotations` object with title, readOnlyHint, destructiveHint, idempotentHint, and openWorldHint'
    - 'Every MCP tool definition includes an `outputSchema` describing the CommandResult<T> JSON shape'
    - 'Every MCP tool description includes a brief example JSON response showing the success case'
    - 'worktree_get_state is annotated readOnlyHint=true, destructiveHint=false'
    - 'worktree_clean is annotated destructiveHint=true'
    - 'worktree_create_pr is annotated readOnlyHint=false, idempotentHint=false'
  artifacts:
    - path: 'src/mcp/server.ts'
      provides: 'All 5 MCP tools with annotations and outputSchema'
      contains: 'annotations'
    - path: 'src/mcp/server.test.ts'
      provides: 'Tests verifying annotations are present on all tools'
      contains: 'annotations'
  key_links:
    - from: 'src/mcp/server.ts'
      to: '@modelcontextprotocol/sdk'
      via: 'Tool type with annotations and outputSchema fields'
      pattern: 'annotations.*readOnlyHint'
---

<objective>
Annotate all 5 MCP tool definitions in `src/mcp/server.ts` with `ToolAnnotations` (behavioral hints), `outputSchema` (JSON response schema), and enriched descriptions that include example JSON responses.

Purpose: Requirement LLM-03 states MCP tool descriptions must include input schema, output schema, and example JSON responses. Currently all 5 tools have no `annotations` or `outputSchema`, and descriptions lack response examples. Adding these helps AI agents select tools correctly (e.g., knowing `worktree_get_state` is read-only avoids unnecessary confirmation prompts) and parse responses reliably.

Output: All 5 MCP tools fully annotated with behavioral hints, output schemas, and enriched descriptions.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-json-output-and-llm-ergonomics/04-RESEARCH.md

@src/mcp/server.ts
@src/lib/json-output.ts (CommandResult<T> types and factory functions)
@src/api/state.ts
@src/api/list.ts
@src/api/clean.ts
@src/api/create.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add annotations, outputSchema, and enriched descriptions to all 5 MCP tools</name>
  <files>src/mcp/server.ts</files>
  <action>
    Update each tool definition in the `tools` array to include `annotations` and `outputSchema` fields, and enrich descriptions with example responses.

    **Import the ToolAnnotations type** (optional — the annotations are plain objects that conform to the Tool type, but importing can help with type checking):
    The existing `Tool` import from `@modelcontextprotocol/sdk/types.js` already includes `annotations` and `outputSchema` as optional fields. No new imports needed.

    **For each tool, add:**

    1. **worktree_get_state:**
       ```typescript
       annotations: {
         title: 'Get Worktree State',
         readOnlyHint: true,
         destructiveHint: false,
         idempotentHint: true,
         openWorldHint: false,
       },
       ```
       Add `outputSchema` with type: 'object' and properties matching `CommandResult<WtstateResultData>`: `success` (boolean), `command` (string), `timestamp` (string), `data` (object with `scenario`, `scenarioDescription`, `currentBranch`, `baseBranch`, `worktreeType`, `hasChanges`, `availableActions`, `recommendedAction`), `error` (object).
       Enrich description to include:
       ```
       Returns a CommandResult JSON with:
       - data.scenario: Git state scenario identifier (e.g., "main_clean_same", "branch_divergent")
       - data.availableActions: Array of {key, label, description} for possible next steps
       - data.recommendedAction: The suggested default action key

       Example success response:
       {"success":true,"command":"wtstate","timestamp":"...","data":{"scenario":"main_clean_same","scenarioDescription":"On main, clean, same as origin","availableActions":[{"key":"empty_commit","label":"Create empty commit"}],"recommendedAction":"empty_commit"}}
       ```

    2. **worktree_create_pr:**
       ```typescript
       annotations: {
         title: 'Create PR with Worktree',
         readOnlyHint: false,
         destructiveHint: false,
         idempotentHint: false,
         openWorldHint: true,
       },
       ```
       Add `outputSchema` matching `CommandResult<NewprResultData>`: `data` with `prNumber`, `prUrl`, `branch`, `worktreePath`, `draft`, `scenario`, `actionTaken`.
       Enrich description with example response showing prNumber, prUrl, worktreePath.

    3. **worktree_setup_pr:**
       ```typescript
       annotations: {
         title: 'Setup PR Worktree',
         readOnlyHint: false,
         destructiveHint: false,
         idempotentHint: true,
         openWorldHint: true,
       },
       ```
       Add `outputSchema` matching the setup result type.
       Enrich description with example response.

    4. **worktree_list:**
       ```typescript
       annotations: {
         title: 'List Worktrees',
         readOnlyHint: true,
         destructiveHint: false,
         idempotentHint: true,
         openWorldHint: true,
       },
       ```
       `openWorldHint: true` because it calls GitHub API for PR status.
       Add `outputSchema` matching the list result.
       Enrich description with example showing worktree array with branch, prNumber, status.

    5. **worktree_clean:**
       ```typescript
       annotations: {
         title: 'Clean Worktrees',
         readOnlyHint: false,
         destructiveHint: true,
         idempotentHint: true,
         openWorldHint: false,
       },
       ```
       `destructiveHint: true` because it removes worktree directories and branches.
       `idempotentHint: true` because cleaning already-cleaned PRs is a no-op.
       Add `outputSchema` matching `CommandResult<CleanprResultData>`.
       Enrich description with example response.

    **outputSchema format** — Each outputSchema must be a JSON Schema object with `type: 'object'`. Keep it minimal but include the key fields that AI agents need. Example:
    ```typescript
    outputSchema: {
      type: 'object' as const,
      properties: {
        success: { type: 'boolean' },
        command: { type: 'string' },
        timestamp: { type: 'string' },
        data: {
          type: 'object',
          properties: {
            // tool-specific fields
          },
        },
        error: {
          type: 'object',
          properties: {
            code: { type: 'string' },
            message: { type: 'string' },
            suggestion: { type: 'string' },
          },
        },
      },
      required: ['success', 'command', 'timestamp'],
    },
    ```

    Also fix the inline error responses in `worktree_create_pr` and `worktree_setup_pr` validation cases to use `createErrorResult()` from json-output.ts instead of manual `JSON.stringify({success: false, error: {code, message}})`. This makes them consistent with the rest of the codebase and includes suggestions.

  </action>
  <verify>
    Run `npm test` — all existing tests pass. Run `npx tsx -e "import {tools} from './src/mcp/server.ts'; tools.forEach(t => console.log(t.name, !!t.annotations, !!t.outputSchema))"` (or similar) to verify all 5 tools have annotations and outputSchema.
  </verify>
  <done>
    All 5 MCP tool definitions have `annotations` with behavioral hints, `outputSchema` with JSON Schema, and descriptions that include example JSON responses. Inline error responses use `createErrorResult()`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for MCP tool annotations and outputSchema</name>
  <files>src/mcp/server.test.ts</files>
  <action>
    Create or update `src/mcp/server.test.ts` to test that all tools have proper annotations and outputSchema:

    1. If `src/mcp/server.test.ts` doesn't exist, create it. If it exists, add to it.
    2. Import the tools array or use the MCP client test helper pattern.
    3. Add test suite "MCP tool definitions":
       - Test: "all tools have annotations" — iterate tools, assert each has `annotations` property with `readOnlyHint`, `destructiveHint`, `idempotentHint`, `openWorldHint` as booleans and `title` as string.
       - Test: "all tools have outputSchema" — iterate tools, assert each has `outputSchema` with `type: 'object'` and `properties.success`.
       - Test: "worktree_get_state is read-only" — assert `annotations.readOnlyHint === true` and `annotations.destructiveHint === false`.
       - Test: "worktree_clean is destructive" — assert `annotations.destructiveHint === true`.
       - Test: "worktree_create_pr is not idempotent" — assert `annotations.idempotentHint === false`.
       - Test: "all tool descriptions mention JSON response" — assert each description includes "CommandResult" or "success" or "JSON" (verify enriched descriptions).
    4. Keep tests focused on the structural annotations (these are static definitions, not runtime behavior). The existing MCP handler tests (if any) should remain unchanged.

  </action>
  <verify>
    Run `npm test -- src/mcp/server.test.ts` — all new tests pass.
  </verify>
  <done>
    Test file verifies all 5 MCP tools have annotations with correct behavioral hints, outputSchema, and enriched descriptions.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes (all existing + new tests)
2. Every tool in the `tools` array has `annotations`, `outputSchema`, and enriched `description`
3. Annotations match the research matrix: get_state=readOnly, create_pr=not-idempotent, clean=destructive
4. Inline error responses in create_pr/setup_pr use `createErrorResult()` not manual JSON
</verification>

<success_criteria>

- All 5 MCP tools have ToolAnnotations with title + 4 boolean hints
- All 5 MCP tools have outputSchema matching CommandResult<T> JSON Schema
- All 5 MCP tool descriptions include example JSON responses
- Inline validation errors use createErrorResult() for consistency
- Tests verify annotations are structurally correct
  </success_criteria>

<output>
After completion, create `.planning/phases/04-json-output-and-llm-ergonomics/04-03-SUMMARY.md`
</output>
