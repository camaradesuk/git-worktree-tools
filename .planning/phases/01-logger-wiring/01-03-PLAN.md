---
phase: 01-logger-wiring
plan: 03
type: tdd
wave: 2
depends_on: ['01-01']
files_modified:
  - src/lib/logger.test.ts
autonomous: true

must_haves:
  truths:
    - 'Tests prove initializeLogger() configures consola level correctly for each flag/env combination'
    - 'Tests prove AuditFileReporter writes entries and rotates at 10MB'
    - 'Tests prove ConditionalStderrReporter routes WARN/ERROR to stderr always, DEBUG/INFO only when verbose'
    - 'Tests prove DEBUG=newpr activates debug level and prints deprecation warning exactly once'
    - 'Tests prove flag precedence: CLI flag > GWT_LOG_LEVEL env var > default (INFO)'
    - 'Tests prove process exit handler writes synchronous audit summary'
  artifacts:
    - path: 'src/lib/logger.test.ts'
      provides: 'Comprehensive test suite for consola-based logger'
      min_lines: 200
  key_links:
    - from: 'src/lib/logger.test.ts'
      to: 'src/lib/logger.ts'
      via: 'import { logger, initializeLogger, parseLogLevel, LogLevel, setAuditContext, _resetForTesting }'
      pattern: 'initializeLogger|parseLogLevel|setAuditContext|_resetForTesting'
---

<objective>
Rewrite `src/lib/logger.test.ts` with comprehensive tests for the new consola-based logger. Cover level resolution, reporter behavior, audit log file operations, rotation, the DEBUG=newpr deprecation path, and the process exit handler.

Purpose: Prove the logger foundation works correctly before the CLI wiring (Plan 02) depends on it. These tests are the safety net for the most critical infrastructure change in Phase 1.

Output: Passing test suite with full coverage of the new logger module.
</objective>

<execution_context>
@/home/chris/.claude/get-shit-done/workflows/execute-plan.md
@/home/chris/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-logger-wiring/01-CONTEXT.md
@.planning/phases/01-logger-wiring/01-RESEARCH.md
@.planning/phases/01-logger-wiring/01-01-SUMMARY.md
@src/lib/logger.ts
@src/lib/logger.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tests for logger initialization, level resolution, and parseLogLevel</name>
  <files>
    src/lib/logger.test.ts
  </files>
  <action>
**Completely rewrite** `src/lib/logger.test.ts` (the old tests are for the old Logger class — they are no longer relevant).

Use vitest (the project's test framework). Test the following:

**parseLogLevel tests:**

- `parseLogLevel('debug')` returns `4`
- `parseLogLevel('info')` returns `3`
- `parseLogLevel('warn')` returns `1`
- `parseLogLevel('warning')` returns `1`
- `parseLogLevel('error')` returns `0`
- `parseLogLevel('silent')` returns `-999` (or whatever value SILENT maps to)
- `parseLogLevel('trace')` returns `5`
- `parseLogLevel('verbose')` returns `4`
- `parseLogLevel('DEBUG')` returns `4` (case insensitive)
- `parseLogLevel('unknown')` returns `undefined`
- `parseLogLevel('')` returns `undefined`

**LogLevel compatibility export:**

- `LogLevel.SILENT` exists and equals the consola silent level
- `LogLevel.ERROR` equals `0`
- `LogLevel.WARN` equals `1`
- `LogLevel.INFO` equals `3`
- `LogLevel.DEBUG` equals `4`
- `LogLevel.TRACE` equals `5`

**initializeLogger level resolution:**

Use `vi.stubEnv()` to control environment variables between tests. Reset logger state between tests (need to figure out how — likely re-import or use a reset function).

Test priority order:

1. `initializeLogger({ quiet: true })` sets level to 0 (error only) regardless of env
2. `initializeLogger({ verbose: true })` sets level to 4 (debug) regardless of env
3. With `GWT_LOG_LEVEL=debug` env var and no flags: level is 4
4. With `GWT_LOG_LEVEL=warn` env var and no flags: level is 1
5. With `GWT_LOG_LEVEL=debug` AND `initializeLogger({ quiet: true })`: level is 0 (CLI flag wins)
6. With no flags and no env var: level is 3 (INFO default)

**DEBUG=newpr deprecation path:** 7. With `DEBUG=newpr` env var: level is 4 AND deprecation warning printed to stderr exactly once

- Mock `process.stderr.write` or use a spy to verify the deprecation message
- Call initializeLogger again — warning must NOT print a second time

8. With `DEBUG=*`: same behavior
9. With `DEBUG=something_else`: level is default (3), no deprecation warning

**Important test setup:**

- Before each test, reset the logger module state by calling `_resetForTesting()` (already exported from logger.ts as part of Plan 01-01 Task 2). This resets the deprecation-warned flag, auditContext, reporters, and logger level.
- After each test, restore original `process.env` values using `vi.unstubAllEnvs()` or explicit cleanup
  </action>
  <verify>
  Run `npm test -- src/lib/logger.test.ts` — all tests pass
  </verify>
  <done>
  parseLogLevel, LogLevel compatibility, initializeLogger level resolution, and DEBUG=newpr deprecation tests all pass. Flag precedence (CLI > env > default) is proven by tests.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Write tests for audit file reporter, rotation, stderr reporter, and exit handler</name>
  <files>
    src/lib/logger.test.ts
  </files>
  <action>
Continue in the same test file. Add test groups for I/O-dependent behavior using temporary directories.

**AuditFileReporter tests:**

Use `os.tmpdir()` + a unique subdirectory for each test. Set `getGlobalDataDir` to return the temp dir (may need to mock `getGlobalDataDir` or pass audit path as option to initializeLogger).

1. After `initializeLogger({ commandName: 'test-cmd' })`, calling `logger.info('test message')` writes a line to the audit log file
2. The audit log file is created in the directory returned by `getGlobalDataDir()`
3. The audit log entry contains: timestamp, level indicator, message text
4. When json mode is active (`initializeLogger({ json: true, commandName: 'test-cmd' })`), entries are valid JSONL (each line parses as JSON)
5. Audit directory is created automatically (test with a non-existent subdirectory)

**Rotation tests:**

1. Create a file larger than 10MB at the audit log path, then call `initializeLogger()`. The old file should be rotated to `audit.log.1` and a new `audit.log` should be started.
2. Create `audit.log` (>10MB), `audit.log.1`, `audit.log.2` — after rotation, `.2` should be deleted, `.1` should become `.2`, original becomes `.1`.
3. Rotation failure (read-only directory) should not crash — tool should continue working with a warning.

**ConditionalStderrReporter tests:**

Use a spy on `process.stderr.write` to capture output.

1. With `verbose: false`: `logger.error('err')` writes to stderr, `logger.warn('wrn')` writes to stderr, `logger.info('inf')` does NOT write to stderr, `logger.debug('dbg')` does NOT write to stderr
2. With `verbose: true` (i.e., `initializeLogger({ verbose: true })`): all levels write to stderr

**Process exit handler tests:**

Testing `process.on('exit')` is tricky. Two approaches:

- Approach A: Spy on `fs.appendFileSync` and trigger the exit handler by calling `process.emit('exit', 0)` in the test (careful: this is an internal event)
- Approach B: The exit handler function should be extractable/testable. If logger.ts exports a `_writeAuditSummary(exitCode)` for testing, call it directly and verify the output.

1. After `initializeLogger({ commandName: 'test' })` and `setAuditContext({ prNumber: 42 })`, calling the summary writer with exit code 0 produces an entry containing: command='test', exitCode=0, prNumber=42, duration (positive number)
2. The summary entry is written synchronously (verify `fs.appendFileSync` is called, not `fs.writeFileSync` or stream.write)
3. If audit log path doesn't exist, summary write fails silently (no crash)

**Test cleanup:**

- Remove temp directories after each test using `fs.rmSync(dir, { recursive: true })`
- Restore all env stubs
  </action>
  <verify>
  Run `npm test -- src/lib/logger.test.ts` — all tests pass, including the new I/O tests
  Run `npm test` — full suite passes (no regressions)
  </verify>
  <done>
  Audit file reporter (write, format, directory creation), rotation (shift, max files, graceful failure), stderr reporter (conditional output by level and verbose flag), and exit handler (synchronous summary write) are all tested. Full test suite passes.
  </done>
  </task>

</tasks>

<verification>
1. `npm test -- src/lib/logger.test.ts` passes with all tests green
2. `npm test` full suite passes (no regressions from logger changes)
3. Test file has coverage for: parseLogLevel, LogLevel compat, level resolution (6 priority scenarios), DEBUG=newpr (3 scenarios), audit file write, JSONL format, rotation (3 scenarios), stderr reporter (2 verbose modes), exit handler (2 scenarios)
</verification>

<success_criteria>

- logger.test.ts is completely rewritten for the consola-based API
- All tests pass
- Flag precedence proven: CLI > env > default
- DEBUG=newpr deprecation warning fires exactly once (proven by test)
- Audit file rotation proven at 10MB threshold
- Stderr reporter conditional output proven for verbose and non-verbose modes
- No test uses the old Logger class, ChildLogger, or removed APIs
  </success_criteria>

<output>
After completion, create `.planning/phases/01-logger-wiring/01-03-SUMMARY.md`
</output>
