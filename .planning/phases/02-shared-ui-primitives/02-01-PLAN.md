# Plan 02-01: Create shared UI primitives module

**Phase:** 2 -- Shared UI Primitives
**Estimated duration:** 30min
**Requirements addressed:** UI-01, UI-02, UI-03, UI-04

## Goal

`src/lib/ui/` module exists with `theme.ts`, `status.ts`, `table.ts`, `error.ts`, `spinner.ts`, and `index.ts` -- all functions are tested, JSON-mode-aware, and ready for CLI refactoring.

## Context

Phase 1 (logger wiring) is complete. The codebase has `src/lib/colors.ts` providing semantic icon functions (`success()`, `warning()`, `error()`, `info()`) and color functions. The spinner lives in `src/lib/prompts.ts` as `withSpinner()`. Error suggestions live in `src/lib/json-output.ts` as `getErrorSuggestion()`. There is no shared output abstraction layer -- each CLI inlines `console.log(colors.something(...))` directly.

This plan creates the shared module. The next plan (02-02) refactors CLIs to use it.

Key constraints:

- Do NOT add any npm dependencies (no ora, no chalk, no cli-table)
- All print functions must no-op when JSON mode is active
- Interactive TUI files (manage-manifest.ts, lswt/interactive.ts, main-menu.ts) are out of scope
- Build on top of `colors.ts` -- import and use its functions, do not duplicate

## Steps

### Step 1: Create `src/lib/ui/theme.ts`

**Files:** `src/lib/ui/theme.ts`
**Action:** create

Create a module that centralizes theme constants consumed by all other ui/ files.

```typescript
// Centralized icons -- these are the canonical icons for non-interactive output.
// colors.ts still provides the semantic functions (success(), error(), etc.)
// that combine icon + color. theme.ts provides the raw constants for cases
// where you need just the icon or just the box-drawing chars.
export const icons = {
  success: '✓',
  error: '✗',
  warning: '⚠',
  info: 'ℹ',
  bullet: '•',
  arrow: '▶',
  change: '*',
} as const;

export const box = {
  horizontal: '═',
  vertical: '║',
  topLeft: '╔',
  topRight: '╗',
  bottomLeft: '╚',
  bottomRight: '╝',
  line: '─',
} as const;
```

Also export a `changeIndicator` function that standardizes the change marker:

```typescript
import * as colors from '../colors.js';

export function changeIndicator(hasChanges: boolean): string {
  return hasChanges ? colors.red(` ${icons.change}`) : '';
}
```

This resolves the inconsistency where lswt uses `colors.red(' *')` and cleanpr uses `colors.red(' [has changes]')`. Standardize on the compact `*` form via this single function.

### Step 2: Create `src/lib/ui/output.ts` (JSON-mode-aware output gate)

**Files:** `src/lib/ui/output.ts`
**Action:** create

Create a module-level JSON mode flag and output function:

```typescript
let jsonMode = false;

export function setJsonMode(enabled: boolean): void {
  jsonMode = enabled;
}

export function isJsonMode(): boolean {
  return jsonMode;
}

// Writes to stdout, suppressed in JSON mode.
// All ui/ print functions call this instead of console.log directly.
export function print(...args: unknown[]): void {
  if (!jsonMode) {
    console.log(...args);
  }
}

// Writes to stderr, suppressed in JSON mode.
export function printErr(...args: unknown[]): void {
  if (!jsonMode) {
    console.error(...args);
  }
}
```

### Step 3: Create `src/lib/ui/status.ts`

**Files:** `src/lib/ui/status.ts`
**Action:** create

Implement status output functions that replace inline `console.log(colors.success(...))` patterns.

Functions to implement:

1. `printStatus(type: 'success' | 'error' | 'warning' | 'info', message: string): void`
   - Calls the corresponding `colors[type](message)` and prints via `print()`.
   - Example: `printStatus('success', 'Prerequisites OK')` outputs the same as `console.log(colors.success('Prerequisites OK'))`.

2. `printHeader(title: string): void`
   - Prints `\n` + `colors.bold(title)` + `\n` via `print()`.
   - Replaces the pattern `console.log(''); console.log(colors.bold('PR Worktrees:')); console.log('');`.

3. `printDetail(label: string, value: string, indent?: number): void`
   - Prints `{indent}  {label}: {value}` via `print()`.
   - Replaces patterns like `console.log('  Branch:    ' + branchName)`.

4. `printDim(message: string, indent?: number): void`
   - Prints `{indent}{colors.dim(message)}` via `print()`.
   - Replaces `console.log(colors.dim(...))` patterns.

5. `printNextSteps(steps: Array<{ command: string; description?: string }>): void`
   - Prints a "Next steps:" section in dim text.
   - Format:
     ```
       Next steps:
         {command}    # {description}
     ```
   - Replaces the duplicated next-steps blocks in newpr.ts and cleanpr.ts.

6. `printSummaryBox(title: string, fields: Array<{ label: string; value: string }>, nextSteps?: Array<{ command: string; description?: string }>): void`
   - Prints the box-drawing summary used by newpr's `printSummary()`:

     ```
     ════════════════════════════════════════
       {title}
     ════════════════════════════════════════

       {label}:    {value}
       ...

       Next steps:
         ...
     ```

   - Uses `box` constants from theme.ts and `colors.green()` for the borders.

### Step 4: Create `src/lib/ui/table.ts`

**Files:** `src/lib/ui/table.ts`
**Action:** create

Extract and generalize the `printTable()` function from `src/cli/lswt.ts` (lines 56-96).

The function should accept a structured options object:

```typescript
interface TableRow {
  label: string; // e.g., the colored type label
  indicator?: string; // e.g., change indicator
  fields: Array<{ key: string; value: string }>;
}

interface TableOptions {
  title?: string;
  rows: TableRow[];
  summary?: string;
  verbose?: boolean;
}

export function printTable(options: TableOptions): void;
```

The implementation should:

- Print title if provided (via `colors.bold()`)
- For each row: print label + indicator, then indented fields
- Print summary if provided (via `colors.dim()`)
- All output via `print()` from output.ts (JSON-mode-aware)

This is NOT a generic table library. It replicates the exact visual format that lswt currently produces, but in a reusable way. The lswt CLI will build the `TableOptions` object from its `WorktreeDisplay[]` data and call `printTable()`.

### Step 5: Create `src/lib/ui/error.ts`

**Files:** `src/lib/ui/error.ts`
**Action:** create

Implement the structured error display function (title + detail + hint).

```typescript
interface ErrorDisplayOptions {
  title: string;
  detail?: string;
  hint?: string;
}

export function printError(options: ErrorDisplayOptions): void;
```

Output format:

```
✗ {title}                    <- via colors.error()
  {detail}                   <- plain text, only if provided
  Hint: {hint}               <- via colors.dim(), only if provided
```

All output goes to stderr via `printErr()`.

Also implement a helper that extracts display info from error objects:

```typescript
import { getErrorCodeFromError, getErrorSuggestion } from '../json-output.js';

export function errorToDisplay(error: unknown): ErrorDisplayOptions {
  const message = error instanceof Error ? error.message : String(error);
  const code = getErrorCodeFromError(error);
  const hint = getErrorSuggestion(code);
  // Extract detail from specific error classes
  let detail: string | undefined;
  if (error instanceof Error && 'stderr' in error) {
    detail = (error as { stderr?: string }).stderr;
  }
  return { title: message, detail, hint };
}
```

This centralizes the repeated pattern of `getErrorCodeFromError(err) -> getErrorSuggestion(code) -> format` that exists in newpr, cleanpr, and lswt top-level catch blocks.

### Step 6: Create `src/lib/ui/spinner.ts`

**Files:** `src/lib/ui/spinner.ts`
**Action:** create

Thin re-export of the existing spinner from prompts.ts. Do NOT reimplement -- just re-export:

```typescript
export { withSpinner } from '../prompts.js';
```

This gives CLI files a single import path (`import { withSpinner } from '../ui/index.js'`) instead of importing from prompts.ts directly. The prompts.ts export remains for backward compatibility.

### Step 7: Create `src/lib/ui/index.ts`

**Files:** `src/lib/ui/index.ts`
**Action:** create

Re-export all public functions:

```typescript
// Theme constants
export { icons, box, changeIndicator } from './theme.js';

// Output gating
export { setJsonMode, isJsonMode, print, printErr } from './output.js';

// Status output
export {
  printStatus,
  printHeader,
  printDetail,
  printDim,
  printNextSteps,
  printSummaryBox,
} from './status.js';

// Table output
export { printTable } from './table.js';
export type { TableRow, TableOptions } from './table.js';

// Error output
export { printError, errorToDisplay } from './error.js';
export type { ErrorDisplayOptions } from './error.js';

// Spinner
export { withSpinner } from './spinner.js';
```

### Step 8: Write tests for the UI module

**Files:** `src/lib/ui/theme.test.ts`, `src/lib/ui/output.test.ts`, `src/lib/ui/status.test.ts`, `src/lib/ui/table.test.ts`, `src/lib/ui/error.test.ts`
**Action:** create

Write unit tests for each module. Test strategy:

**theme.test.ts:**

- `changeIndicator(true)` returns string containing `*`
- `changeIndicator(false)` returns empty string
- Icons and box constants are defined

**output.test.ts:**

- `setJsonMode(true)` causes `print()` to suppress output (spy on console.log)
- `setJsonMode(false)` causes `print()` to output normally
- `printErr()` similarly controlled by JSON mode
- After each test, reset JSON mode to false

**status.test.ts:**

- `printStatus('success', 'Done')` calls console.log once with string containing the success icon
- `printHeader('Title')` calls console.log with bold text
- `printNextSteps([...])` outputs formatted step list
- `printSummaryBox(...)` outputs box-drawing border pattern
- All functions no-op when JSON mode is active

**table.test.ts:**

- `printTable({ rows: [...] })` outputs formatted rows
- Empty rows array shows nothing (or "No items" message)
- Summary line printed when provided
- No-op in JSON mode

**error.test.ts:**

- `printError({ title: 'Fail' })` writes to stderr with error icon
- `printError({ title: 'Fail', detail: 'more', hint: 'try X' })` writes all three lines
- `errorToDisplay(new Error('test'))` returns correct ErrorDisplayOptions
- No-op in JSON mode

Each test file should use `vi.spyOn(console, 'log')` and `vi.spyOn(console, 'error')` to capture output. Reset JSON mode in `afterEach`.

## Verification

- [ ] `npm run build` succeeds with no TypeScript errors
- [ ] `npm test` passes -- all 231+ existing tests still pass
- [ ] New test files pass: `npx vitest run src/lib/ui/`
- [ ] `src/lib/ui/index.ts` exports: `printStatus`, `printHeader`, `printDetail`, `printDim`, `printNextSteps`, `printSummaryBox`, `printTable`, `printError`, `errorToDisplay`, `setJsonMode`, `isJsonMode`, `withSpinner`, `icons`, `box`, `changeIndicator`
- [ ] No new npm dependencies added (check `package.json` is unchanged)
- [ ] All print functions suppress output when `setJsonMode(true)` is called

## Notes

- The `printSummaryBox` function should use the `box` constants from theme.ts, not hardcoded unicode. The width should be calculated from the title length or a fixed width matching the existing newpr output (~58 chars).
- `changeIndicator()` standardizes on `*` (compact form). When plan 02-02 refactors cleanpr, it will switch from `[has changes]` to `*` via this function.
- The `print()` / `printErr()` functions in output.ts are the JSON-mode gate. Every other ui/ function calls these instead of `console.log` / `console.error` directly. This means a single `setJsonMode(true)` call in CLI init silences all structured output.
- Do NOT move `withSpinner` implementation out of prompts.ts -- just re-export. Moving it would break any code that already imports from prompts.ts.
